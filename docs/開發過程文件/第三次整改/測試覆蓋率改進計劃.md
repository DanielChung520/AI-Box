# 測試覆蓋率改進計劃

**版本**：1.0
**創建日期**：**創建日期**：2025-12-21
**創建人**：Daniel Chung
**目標**：將測試覆蓋率提升到 > 80%

---

## 當前測試覆蓋率狀況

| 模塊                | 當前覆蓋率 | 目標覆蓋率 | 差距 | 優先級 |
| ------------------- | ---------- | ---------- | ---- | ------ |
| Task Tracker        | 100%       | 100%       | ✅   | -      |
| System Config Agent | 70%        | 80%        | 10%  | 🟡 中  |
| LogService          | 51%        | 80%        | 29%  | 🔴 高  |
| Orchestrator        | 31%        | 80%        | 49%  | 🔴 高  |
| Task Analyzer       | 25%        | 80%        | 55%  | 🔴 高  |

---

## 改進策略

### 總體原則

1. **優先級驅動**：先改進覆蓋率最低的模塊（LogService、Orchestrator、Task Analyzer）
2. **增量改進**：每次改進一個模塊，確保測試通過後再繼續
3. **重點覆蓋**：優先覆蓋核心業務邏輯和關鍵路徑
4. **邊界測試**：補充邊界條件和異常情況測試

---

## 1. LogService 改進計劃（51% → 80%）

### 當前狀況分析

**未覆蓋的主要區域**（根據覆蓋率報告）：

- 行 68, 71：錯誤處理路徑
- 行 141-142：某些查詢方法的路徑
- 行 161-215：部分查詢方法的實現
- 行 247, 254-255：某些方法的路徑
- 行 281, 289-292：某些方法的路徑
- 行 400, 412-415：某些方法的路徑
- 行 441, 467-470：某些方法的路徑
- 行 494, 518-521：某些方法的路徑
- 行 541-571：批量日誌寫入相關代碼
- 行 593-668：某些查詢方法的實現

### 改進任務

#### 任務 1.1：補充查詢方法測試（優先級：🔴 高）

**目標**：覆蓋所有查詢方法的各種場景

**需要補充的測試**：

- [ ] `get_logs_by_trace_id()` - 測試多條日誌的情況
- [ ] `get_logs_by_trace_id()` - 測試空結果的情況
- [ ] `get_logs_by_trace_id()` - 測試 limit 參數
- [ ] `get_audit_logs()` - 測試按時間範圍查詢
- [ ] `get_audit_logs()` - 測試按 actor 過濾
- [ ] `get_audit_logs()` - 測試按 action 過濾
- [ ] `get_security_logs()` - 測試各種過濾條件組合
- [ ] `get_security_logs()` - 測試排序功能

**預計提升**：+10-15%

#### 任務 1.2：補充錯誤處理測試（優先級：🔴 高）

**目標**：覆蓋所有錯誤處理路徑

**需要補充的測試**：

- [ ] 數據庫連接失敗的情況
- [ ] Collection 不存在的情況
- [ ] 索引創建失敗的情況
- [ ] 插入失敗的情況
- [ ] 查詢異常的情況

**預計提升**：+5-8%

#### 任務 1.3：補充批量操作測試（優先級：🟡 中）

**目標**：覆蓋批量日誌寫入功能（如果存在）

**需要補充的測試**：

- [ ] 批量日誌寫入
- [ ] 批量操作的錯誤處理
- [ ] 批量操作的性能測試

**預計提升**：+3-5%

#### 任務 1.4：補充邊界條件測試（優先級：🟡 中）

**目標**：覆蓋各種邊界情況

**需要補充的測試**：

- [ ] 空內容的日誌記錄
- [ ] 超大內容的日誌記錄
- [ ] 特殊字符的處理
- [ ] None 值的處理
- [ ] 空的 trace_id 處理

**預計提升**：+2-4%

### 實施步驟

1. 查看 `log_service.py` 的完整代碼，確認未覆蓋的具體方法
2. 為每個未覆蓋的方法編寫測試用例
3. 運行測試，確保覆蓋率達到 80%
4. 修復測試中發現的問題

---

## 2. Orchestrator 改進計劃（31% → 80%）

### 當前狀況分析

**未覆蓋的主要區域**（根據覆蓋率報告）：

- 行 78, 95, 112：初始化相關代碼
- 行 141-161, 166-185：某些核心方法
- 行 198-231：某些方法的實現
- 行 244-273：某些方法的實現
- 行 290-371：某些方法的實現
- 行 390-416：某些方法的實現
- 行 584-779：`process_natural_language_request()` 方法的實現
- 行 800-864：某些方法的實現
- 行 880-900, 919-983：某些方法的實現

### 改進任務

#### 任務 2.1：補充核心流程測試（優先級：🔴 高）

**目標**：覆蓋 `process_natural_language_request()` 方法的完整流程

**需要補充的測試**：

- [ ] 完整的自然語言請求處理流程（端到端）
- [ ] Task Analyzer 調用和結果處理
- [ ] 第一層預檢的成功路徑
- [ ] 第一層預檢的失敗路徑
- [ ] Security Agent 權限檢查的各種情況
- [ ] Agent 調用和結果聚合
- [ ] 結果修飾和返回

**預計提升**：+20-25%

#### 任務 2.2：補充預檢邏輯測試（優先級：🔴 高）

**目標**：覆蓋所有預檢邏輯的路徑

**需要補充的測試**：

- [ ] `_pre_check_config_intent()` - 各種配置場景
- [ ] `_validate_field()` - 各種類型驗證
- [ ] `_check_type()` - 所有類型檢查
- [ ] 複雜的配置驗證場景
- [ ] 嵌套配置的驗證

**預計提升**：+10-15%

#### 任務 2.3：補充權限檢查測試（優先級：🟡 中）

**目標**：覆蓋所有權限檢查場景

**需要補充的測試**：

- [ ] `_check_permission()` - 各種權限場景
- [ ] Security Agent 不可用的情況
- [ ] 權限拒絕的情況
- [ ] 需要二次確認的情況
- [ ] 風險評估的各種情況

**預計提升**：+5-8%

#### 任務 2.4：補充錯誤處理測試（優先級：🟡 中）

**目標**：覆蓋所有錯誤處理路徑

**需要補充的測試**：

- [ ] Task Analyzer 失敗的情況
- [ ] Agent 調用失敗的情況
- [ ] 結果聚合失敗的情況
- [ ] 各種異常情況的處理

**預計提升**：+5-8%

#### 任務 2.5：補充結果修飾測試（優先級：🟢 低）

**目標**：覆蓋結果修飾功能

**需要補充的測試**：

- [ ] `_format_result()` - 各種結果格式
- [ ] `_format_result_simple()` - 簡單結果格式化
- [ ] LLM Router 調用和結果處理

**預計提升**：+3-5%

### 實施步驟

1. 分析 `orchestrator.py` 的核心方法，確定測試優先級
2. 先補充核心流程測試（`process_natural_language_request`）
3. 補充預檢邏輯測試
4. 補充權限檢查和錯誤處理測試
5. 運行測試，確保覆蓋率達到 80%

---

## 3. Task Analyzer 改進計劃（25% → 80%）

### 當前狀況分析

**未覆蓋的主要區域**：

- `analyze()` 方法的完整流程
- 各種分類場景
- 工作流選擇邏輯
- LLM 路由選擇邏輯
- 配置操作識別的其他場景

### 改進任務

#### 任務 3.1：補充核心分析方法測試（優先級：🔴 高）

**目標**：覆蓋 `analyze()` 方法的完整流程

**需要補充的測試**：

- [ ] 完整的任務分析流程（端到端）
- [ ] 各種任務類型的分類
- [ ] 各種工作流類型的選擇
- [ ] 各種 LLM 提供商的選擇
- [ ] Agent 需求判斷邏輯

**預計提升**：+30-35%

#### 任務 3.2：補充配置操作解析測試（優先級：🟡 中）

**目標**：擴展現有的配置操作解析測試

**需要補充的測試**：

- [ ] `_is_config_operation()` - 更多關鍵詞組合
- [ ] `_extract_config_intent()` - 更多複雜場景
- [ ] 各種澄清場景
- [ ] 各種槽位缺失情況

**預計提升**：+10-15%

#### 任務 3.3：補充分類器測試（優先級：🟡 中）

**目標**：覆蓋分類器的各種場景

**需要補充的測試**：

- [ ] TaskClassifier 的各種分類場景
- [ ] WorkflowSelector 的各種選擇場景
- [ ] LLMRouter 的各種路由場景

**預計提升**：+5-10%

#### 任務 3.4：補充錯誤處理測試（優先級：🟢 低）

**目標**：覆蓋錯誤處理路徑

**需要補充的測試**：

- [ ] LLM 調用失敗的情況
- [ ] JSON 解析失敗的情況
- [ ] 各種異常情況的處理

**預計提升**：+3-5%

### 實施步驟

1. 分析 `analyzer.py` 的核心方法
2. 補充 `analyze()` 方法的完整流程測試
3. 擴展現有的配置操作解析測試
4. 補充分類器和路由器的測試
5. 運行測試，確保覆蓋率達到 80%

---

## 4. System Config Agent 改進計劃（70% → 80%）

### 當前狀況分析

**已達到 70% 覆蓋率**，距離目標 80% 還有 10% 的差距。

### 改進任務

#### 任務 4.1：補充異常處理測試（優先級：🟡 中）

**目標**：覆蓋更多異常處理路徑

**需要補充的測試**：

- [ ] rollback 失敗的各種情況
- [ ] 預覽確認流程（高風險操作）
- [ ] 合規檢查失敗的各種情況
- [ ] 數據庫操作失敗的情況

**預計提升**：+5-8%

#### 任務 4.2：補充邊界條件測試（優先級：🟡 中）

**目標**：覆蓋更多邊界情況

**需要補充的測試**：

- [ ] 超大配置數據的處理
- [ ] 嵌套配置的各種情況
- [ ] 複雜的配置合併場景

**預計提升**：+3-5%

---

## 實施時間表

### 階段 1：LogService 改進（優先級：🔴 高）

**預計時間**：1-2 天

- [ ] 任務 1.1：補充查詢方法測試（4-6 小時）
- [ ] 任務 1.2：補充錯誤處理測試（2-3 小時）
- [ ] 任務 1.3：補充批量操作測試（2-3 小時）
- [ ] 任務 1.4：補充邊界條件測試（2-3 小時）

**目標**：LogService 覆蓋率從 51% 提升到 80%

### 階段 2：Orchestrator 改進（優先級：🔴 高）

**預計時間**：2-3 天

- [ ] 任務 2.1：補充核心流程測試（8-10 小時）
- [ ] 任務 2.2：補充預檢邏輯測試（4-6 小時）
- [ ] 任務 2.3：補充權限檢查測試（2-3 小時）
- [ ] 任務 2.4：補充錯誤處理測試（2-3 小時）
- [ ] 任務 2.5：補充結果修飾測試（2-3 小時）

**目標**：Orchestrator 覆蓋率從 31% 提升到 80%

### 階段 3：Task Analyzer 改進（優先級：🔴 高）

**預計時間**：2-3 天

- [ ] 任務 3.1：補充核心分析方法測試（8-10 小時）
- [ ] 任務 3.2：補充配置操作解析測試（4-6 小時）
- [ ] 任務 3.3：補充分類器測試（2-3 小時）
- [ ] 任務 3.4：補充錯誤處理測試（2-3 小時）

**目標**：Task Analyzer 覆蓋率從 25% 提升到 80%

### 階段 4：System Config Agent 改進（優先級：🟡 中）

**預計時間**：1 天

- [ ] 任務 4.1：補充異常處理測試（4-6 小時）
- [ ] 任務 4.2：補充邊界條件測試（2-3 小時）

**目標**：System Config Agent 覆蓋率從 70% 提升到 80%

---

## 改進建議的具體實施方法

### 1. 使用覆蓋率報告指導測試編寫

```bash
# 生成詳細的覆蓋率報告
pytest --cov=services.api.core.log.log_service --cov-report=term-missing tests/services/api/core/log/test_log_service.py

# 查看 HTML 報告（更直觀）
pytest --cov=services.api.core.log.log_service --cov-report=html tests/services/api/core/log/test_log_service.py
# 然後打開 htmlcov/index.html 查看未覆蓋的代碼行
```

### 2. 測試用例編寫模式

#### 模式 1：方法級測試（Method-level Testing）

```python
@pytest.mark.asyncio
async def test_method_name_success_case(self, fixture):
    """測試方法成功的情況"""
    # Arrange
    # Act
    result = await service.method_name(params)
    # Assert
    assert result is not None

@pytest.mark.asyncio
async def test_method_name_failure_case(self, fixture):
    """測試方法失敗的情況"""
    # Arrange
    # Act & Assert
    with pytest.raises(ExpectedException):
        await service.method_name(invalid_params)
```

#### 模式 2：路徑覆蓋測試（Path Coverage Testing）

```python
@pytest.mark.asyncio
async def test_method_name_path_1(self, fixture):
    """測試路徑 1：condition A 為 True"""
    # 設置條件使 A 為 True
    # 執行方法
    # 驗證結果

@pytest.mark.asyncio
async def test_method_name_path_2(self, fixture):
    """測試路徑 2：condition A 為 False"""
    # 設置條件使 A 為 False
    # 執行方法
    # 驗證結果
```

#### 模式 3：邊界值測試（Boundary Value Testing）

```python
@pytest.mark.asyncio
async def test_method_name_boundary_min(self, fixture):
    """測試最小值邊界"""
    # 使用最小值參數
    # 執行方法
    # 驗證結果

@pytest.mark.asyncio
async def test_method_name_boundary_max(self, fixture):
    """測試最大值邊界"""
    # 使用最大值參數
    # 執行方法
    # 驗證結果
```

### 3. Mock 使用最佳實踐

```python
# ✅ 正確：Mock 外部依賴
@patch("service.external_dependency")
async def test_with_mock(mock_dependency):
    mock_dependency.method.return_value = expected_value
    result = await service.method()
    assert result == expected_result

# ✅ 正確：Mock 異步方法
@patch.object(service, "async_method", new_callable=AsyncMock)
async def test_with_async_mock(mock_method):
    mock_method.return_value = expected_value
    result = await service.method()
    mock_method.assert_called_once()
```

---

## 預期成果

### 階段性目標

| 階段 | 模塊                | 目標覆蓋率 | 預計完成時間 |
| ---- | ------------------- | ---------- | ------------ |
| 1    | LogService          | 80%        | 1-2 天       |
| 2    | Orchestrator        | 80%        | 2-3 天       |
| 3    | Task Analyzer       | 80%        | 2-3 天       |
| 4    | System Config Agent | 80%        | 1 天         |

### 總體目標

- ✅ 所有核心模塊覆蓋率 > 80%
- ✅ 總測試用例數 > 150 個
- ✅ 所有測試通過率 100%
- ✅ 關鍵業務邏輯 100% 覆蓋

---

## 檢查清單

### 測試編寫檢查清單

- [ ] 測試用例名稱清晰描述測試場景
- [ ] 測試用例包含 Arrange-Act-Assert 結構
- [ ] 測試用例包含適當的文檔字符串
- [ ] 使用 Mock 隔離外部依賴
- [ ] 測試覆蓋正常路徑
- [ ] 測試覆蓋異常路徑
- [ ] 測試覆蓋邊界條件
- [ ] 測試通過所有檢查（black, ruff, mypy）
- [ ] 測試執行通過

### 覆蓋率檢查清單

- [ ] 生成覆蓋率報告
- [ ] 確認覆蓋率達到目標
- [ ] 檢查未覆蓋的代碼行
- [ ] 確認未覆蓋的代碼是否需要測試
- [ ] 補充缺失的測試用例
- [ ] 重新運行覆蓋率檢查

---

## 資源需求

### 時間資源

- **總計**：6-9 天
- **階段 1（LogService）**：1-2 天
- **階段 2（Orchestrator）**：2-3 天
- **階段 3（Task Analyzer）**：2-3 天
- **階段 4（System Config Agent）**：1 天

### 技能需求

- Python 測試框架（pytest）使用經驗
- Mock 和 Fixture 使用經驗
- 代碼覆蓋率工具使用經驗
- 對被測試模塊的理解

---

## 參考資源

### 測試文檔

- [pytest 官方文檔](https://docs.pytest.org/)
- [coverage.py 官方文檔](https://coverage.readthedocs.io/)
- [unittest.mock 官方文檔](https://docs.python.org/3/library/unittest.mock.html)

### 項目文檔

- [測試執行摘要報告](../../tests/TEST_EXECUTION_SUMMARY.md)
- [覆蓋率改進總結報告](../../tests/COVERAGE_IMPROVEMENT_SUMMARY.md)
- [系統整改完成總結報告](./系統整改完成總結報告.md)

---

**文檔版本**：1.0
**創建日期**：2025-01-27
**維護者**：Daniel Chung
