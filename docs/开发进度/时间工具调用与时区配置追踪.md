# 时间工具调用与时区配置追踪

**版本**: 1.1
**創建日期**: 2026-01-06
**創建人**: Daniel Chung
**最後修改日期**: 2026-01-06

---

## 📋 问题描述

**用户查询**："現在時間" 或 "現在幾點"

**预期行为**：

1. AI 应该调用 `datetime` 工具获取当前时间
2. 工具应该使用用户的时区配置（而不是默认 UTC）
3. 返回格式化的时间字符串

**实际行为**：

- AI 可能没有调用时间工具，直接回答
- 或者调用了工具，但时区不正确（使用 UTC 而不是用户时区）

**当前时间**：2026-01-06 10:29:48（时区：UTC）

---

## 🔍 完整调用流程追踪

### 1. API 入口

**文件**: `api/routers/chat.py`
**函数**: `chat_product_stream()`
**行号**: 1159-2791

**关键代码**：

```python
# 获取用户输入
messages = [m.model_dump() for m in request_body.messages]
last_user_text = messages[-1].get("content", "") if messages else ""

# 获取工具列表
allowed_tools = request_body.allowed_tools or []
```

**tenant_id 和 user_id 获取**：

```python
tenant_id: str = Depends(get_current_tenant_id),
current_user: User = Depends(get_current_user),
```

---

### 2. Layer 0: Cheap Gating（快速过滤）

**文件**: `agents/task_analyzer/analyzer.py`
**行号**: 70-74

**功能**: 快速检查是否为简单查询

**关键代码**：

```python
if self._is_simple_query(request.task):
    return await self._handle_simple_query(request, task_id)
```

**时间查询处理**：

- 如果检测到时间查询关键词（"時間"、"現在"、"此刻"等），可能进入快速路径

---

### 3. 快速路径（Quick Path）

**文件**: `api/routers/chat.py`
**行号**: 1230-1268

**触发条件**：

- 检测到时间查询关键词
- 在 `allowed_tools` 中包含 `datetime` 工具

**关键代码**：

```python
# 检测时间查询
if any(keyword in last_user_text.lower() for keyword in ["時間", "時間", "time", "現在", "此刻", "當前"]):
    if "datetime" in allowed_tools:
        # 直接调用 datetime 工具
        from tools.time import DateTimeInput, DateTimeTool

        datetime_tool = DateTimeTool()
        datetime_input = DateTimeInput(
            tenant_id=current_user.tenant_id if hasattr(current_user, "tenant_id") else None,
            user_id=current_user.user_id,
        )
        tool_result = await datetime_tool.execute(datetime_input)

        # 格式化返回
        time_response = f"現在的時間是：{tool_result.datetime}"
        if hasattr(tool_result, "timezone"):
            time_response += f"（時區：{tool_result.timezone}）"
```

**时区配置传递**：

- ✅ `tenant_id` 和 `user_id` 被正确传递到 `DateTimeInput`
- ✅ 工具会从配置中读取默认时区

---

### 4. Layer 1-3: Task Analyzer 路径

**文件**: `api/routers/chat.py`
**行号**: 1400-1465

**流程**：

1. **Layer 1**: Fast Answer Layer（高级 LLM 判断）
2. **Layer 2**: Semantic Intent Analysis（Router LLM 意图分类）
3. **Layer 3**: Decision Engine（Capability Matcher + Decision Engine）

**关键代码**：

```python
# Task Analyzer 选择工具
task_analyzer_result = await task_analyzer.analyze(...)

# 如果选择了 datetime 工具
if task_analyzer_result.selected_tools and "datetime" in task_analyzer_result.selected_tools:
    from tools.time import DateTimeInput, DateTimeTool

    datetime_tool = DateTimeTool()
    datetime_input = DateTimeInput(
        tenant_id=tenant_id,
        user_id=current_user.user_id,
    )
    tool_result = await datetime_tool.execute(datetime_input)

    # 格式化返回
    time_response = f"現在的時間是：{tool_result.datetime}"
    if hasattr(tool_result, "timezone"):
        time_response += f"（時區：{tool_result.timezone}）"
```

**时区配置传递**：

- ✅ `tenant_id` 和 `user_id` 被正确传递到 `DateTimeInput`

---

### 5. Capability Matcher（工具匹配）

**文件**: `agents/task_analyzer/capability_matcher.py`
**行号**: 328-446

**功能**: 匹配用户查询与可用工具

**关键代码**：

```python
# 基于工具名称和类别的匹配（优先级最高）
if tool_name == "datetime" and any(
    keyword in user_query_lower
    for keyword in [
        "時間",
        "時間",
        "time",
        "現在",
        "此刻",
        "當前",
        "當前時間",
        "現在幾點",
    ]
):
    # datetime 工具 + 时间查询 = 完美匹配
    name_category_match = 1.0
elif tool_category == "時間與日期" and any(
    keyword in user_query_lower
    for keyword in ["時間", "時間", "time", "現在", "此刻", "當前", "日期", "date"]
):
    # 时间类别工具 + 时间查询 = 高匹配度
    name_category_match = 0.9
```

**匹配逻辑**：

- ✅ 如果查询包含时间相关关键词，`datetime` 工具应该被匹配到
- ✅ 匹配度：1.0（完美匹配）或 0.9（高匹配度）

---

### 6. DateTimeTool 执行

**文件**: `tools/time/datetime_tool.py`
**行号**: 130-194

**执行流程**：

```python
async def execute(self, input_data: DateTimeInput) -> DateTimeOutput:
    # 1. 获取高精度时间
    time_service = get_time_service()
    current_timestamp = time_service.now()
    current_datetime_utc = time_service.now_utc_datetime()

    # 2. 读取配置
    config = self._get_config(input_data.tenant_id, input_data.user_id)

    # 3. 确定时区（优先级：用户指定 > 配置 > 系统时区 > UTC）
    timezone_str = (
        input_data.timezone
        or config.get("default_timezone")
        or self._get_system_timezone()  # ✅ 自动检测系统时区
        or "UTC"
    )

    # 4. 转换到指定时区
    tz = pytz.timezone(timezone_str)
    current_datetime = current_datetime_utc.astimezone(tz)

    # 5. 格式化日期时间
    format_str = input_data.format or config.get("default_format", "%Y-%m-%d %H:%M:%S")
    formatted_datetime = current_datetime.strftime(format_str)

    # 6. 返回结果
    return DateTimeOutput(
        datetime=formatted_datetime,
        timestamp=current_timestamp,
        timezone=timezone_str,
        iso_format=iso_formatted,
        local_format=local_formatted,
    )
```

**时区配置读取**：

```python
def _get_config(self, tenant_id: Optional[str], user_id: Optional[str]) -> Dict[str, Any]:
    config_service = get_config_store_service()

    # 读取有效配置（自动合并 system > tenant > user）
    effective_config = config_service.get_effective_config(
        scope="tools.datetime",
        tenant_id=tenant_id,
        user_id=user_id,
    )
    return effective_config.config
```

**默认配置**：

```python
def _get_default_config(self) -> Dict[str, Any]:
    system_timezone = self._get_system_timezone()  # ✅ 自动检测系统时区
    return {
        "default_format": "%Y-%m-%d %H:%M:%S",
        "default_timezone": system_timezone,  # ✅ 使用系统时区而不是 UTC
        "default_locale": "en_US",
        # ...
    }
```

**系统时区检测**：

```python
def _get_system_timezone(self) -> str:
    """获取系统时区"""
    # 1. 尝试从时区对象获取名称
    local_tz = datetime.now().astimezone().tzinfo
    if hasattr(local_tz, "zone"):
        return local_tz.zone

    # 2. 如果无法获取名称，从偏移量推断（UTC+8 -> Asia/Taipei）
    offset_hours = datetime.now().astimezone().utcoffset().total_seconds() / 3600
    if offset_hours == 8:
        return "Asia/Taipei"
    # ... 其他常见时区

    # 3. 最后回退到 UTC
    return "UTC"
```

**时区优先级**（从高到低）：

1. ✅ **用户指定**：`input_data.timezone`
2. ✅ **配置读取**：从 ConfigStoreService 读取（system > tenant > user）
3. ✅ **系统时区**：自动检测服务器时区（**新增**）
4. ✅ **UTC**：最后回退

---

## 🔍 问题分析

### 问题 1: AI 没有调用时间工具

**可能原因**：

1. **快速路径未触发**：
   - 关键词匹配失败
   - `allowed_tools` 中不包含 `datetime`
   - 快速路径逻辑被跳过

2. **Task Analyzer 未匹配到工具**：
   - Capability Matcher 匹配失败
   - Decision Engine 选择了其他方案（如直接回答）
   - 工具匹配度不够高

3. **LLM 直接回答**：
   - LLM 认为可以直接回答，不需要调用工具
   - 工具定义没有正确传递给 LLM
   - LLM 的 function calling 被禁用

**检查点**：

- [ ] `allowed_tools` 是否包含 `datetime`？
- [ ] 快速路径是否被触发？
- [ ] Task Analyzer 是否匹配到 `datetime` 工具？
- [ ] LLM 是否收到工具定义？

---

### 问题 2: 时区不正确（使用 UTC 而不是用户时区）

**可能原因**：

1. **配置未设置**：
   - 系统级配置：`default_timezone: "UTC"`（默认值）
   - 租户级配置：未设置
   - 用户级配置：未设置

2. **配置读取失败**：
   - `ConfigStoreService` 读取失败
   - 回退到默认配置（UTC）

3. **tenant_id/user_id 未传递**：
   - `DateTimeInput` 中 `tenant_id` 或 `user_id` 为 `None`
   - 工具无法读取用户级配置

**检查点**：

- [ ] 用户时区配置是否存在？
- [ ] `tenant_id` 和 `user_id` 是否正确传递？
- [ ] 配置读取是否成功？
- [ ] 时区转换是否正确？

---

## 🎯 解决方案

### 方案 1: 确保工具被调用

**步骤**：

1. **检查快速路径**：

   ```python
   # 在 api/routers/chat.py 中添加日志
   logger.info(
       "quick_path_check",
       query=last_user_text,
       allowed_tools=allowed_tools,
       has_datetime="datetime" in allowed_tools,
   )
   ```

2. **检查 Task Analyzer 匹配**：

   ```python
   # 在 capability_matcher.py 中添加日志
   logger.info(
       "datetime_tool_match",
       query=user_query,
       matched_tools=[m.candidate_id for m in matches],
       datetime_match=[m for m in matches if m.candidate_id == "datetime"],
   )
   ```

3. **确保工具定义传递给 LLM**：

   ```python
   # 检查 moe_context 中的 allowed_tools
   if allowed_tools:
       moe_context["allowed_tools"] = allowed_tools
       logger.debug("tools_enabled", allowed_tools=allowed_tools)
   ```

---

### 方案 2: 修复时区配置

**步骤**：

1. **设置用户时区配置**：

   ```python
   # 在 ArangoDB 中设置用户级配置
   config_service.set_config(
       scope="tools.datetime",
       tenant_id=tenant_id,
       user_id=user_id,
       config_data={
           "default_timezone": "Asia/Taipei",  # 用户时区
           "default_format": "%Y-%m-%d %H:%M:%S",
       },
   )
   ```

2. **检查配置读取**：

   ```python
   # 在 datetime_tool.py 中添加日志
   logger.info(
       "config_read",
       tenant_id=tenant_id,
       user_id=user_id,
       config=config,
       timezone=timezone_str,
   )
   ```

3. **验证时区转换**：

   ```python
   # 在 execute 方法中添加日志
   logger.info(
       "timezone_conversion",
       utc_time=current_datetime_utc.isoformat(),
       target_timezone=timezone_str,
       local_time=current_datetime.isoformat(),
   )
   ```

---

## 📊 调试检查清单

### 1. 工具调用检查

- [ ] **快速路径检查**：
  - 查询是否包含时间关键词？
  - `allowed_tools` 是否包含 `datetime`？
  - 快速路径是否被触发？

- [ ] **Task Analyzer 检查**：
  - Capability Matcher 是否匹配到 `datetime` 工具？
  - Decision Engine 是否选择 `datetime` 工具？
  - 工具是否被执行？

- [ ] **LLM Function Calling 检查**：
  - LLM 是否收到工具定义？
  - LLM 是否选择调用 `datetime` 工具？
  - 工具调用结果是否正确返回？

---

### 2. 时区配置检查

- [ ] **配置存在性检查**：
  - 系统级配置是否存在？
  - 租户级配置是否存在？
  - 用户级配置是否存在？

- [ ] **配置读取检查**：
  - `tenant_id` 是否正确传递？
  - `user_id` 是否正确传递？
  - 配置读取是否成功？
  - 读取的配置内容是什么？

- [ ] **时区转换检查**：
  - UTC 时间是否正确？
  - 目标时区是什么？
  - 时区转换是否正确？
  - 格式化后的时间是什么？

---

## 🔧 代码修改建议

### 1. 增强日志记录

**文件**: `api/routers/chat.py`

```python
# 在快速路径检查处添加日志
logger.info(
    "quick_path_datetime_check",
    query=last_user_text,
    allowed_tools=allowed_tools,
    has_datetime="datetime" in allowed_tools,
    tenant_id=tenant_id,
    user_id=current_user.user_id,
)

# 在工具执行处添加日志
logger.info(
    "datetime_tool_execution",
    tenant_id=datetime_input.tenant_id,
    user_id=datetime_input.user_id,
    result_timezone=tool_result.timezone,
    result_datetime=tool_result.datetime,
)
```

**文件**: `tools/time/datetime_tool.py`

```python
# 在配置读取处添加日志
logger.info(
    "datetime_config_read",
    tenant_id=tenant_id,
    user_id=user_id,
    config=config,
    default_timezone=config.get("default_timezone"),
)

# 在时区转换处添加日志
logger.info(
    "datetime_timezone_conversion",
    utc_time=current_datetime_utc.isoformat(),
    target_timezone=timezone_str,
    local_time=current_datetime.isoformat(),
    formatted_time=formatted_datetime,
)
```

---

### 2. 添加时区配置验证

**文件**: `tools/time/datetime_tool.py`

```python
async def execute(self, input_data: DateTimeInput) -> DateTimeOutput:
    # ... 现有代码 ...

    # 验证时区配置
    if timezone_str == "UTC" and input_data.tenant_id and input_data.user_id:
        logger.warning(
            "using_utc_timezone",
            tenant_id=input_data.tenant_id,
            user_id=input_data.user_id,
            message="用户时区配置未设置，使用默认 UTC",
        )

    # ... 现有代码 ...
```

---

### 3. 添加配置设置 API

**文件**: `api/routers/config.py`（新建或扩展）

```python
@router.post("/tools/datetime/config")
async def set_datetime_config(
    config_data: Dict[str, Any],
    tenant_id: str = Depends(get_current_tenant_id),
    current_user: User = Depends(get_current_user),
):
    """设置用户时区配置"""
    config_service = get_config_store_service()

    config_service.set_config(
        scope="tools.datetime",
        tenant_id=tenant_id,
        user_id=current_user.user_id,
        config_data=config_data,
    )

    return {"status": "success"}
```

---

## 📝 测试用例

### 测试用例 1: 快速路径调用

**查询**: "現在時間"

**预期流程**：

1. ✅ 快速路径检测到时间关键词
2. ✅ `allowed_tools` 包含 `datetime`
3. ✅ 直接调用 `datetime` 工具
4. ✅ 返回格式化的时间（用户时区）

**验证点**：

- 日志中是否有 `quick_path_datetime_check`？
- 日志中是否有 `datetime_tool_execution`？
- 返回的时间时区是否正确？

---

### 测试用例 2: Task Analyzer 路径调用

**查询**: "告訴我現在幾點"

**预期流程**：

1. ✅ 快速路径未触发
2. ✅ Task Analyzer 匹配到 `datetime` 工具
3. ✅ Decision Engine 选择 `datetime` 工具
4. ✅ 执行工具并返回结果

**验证点**：

- 日志中是否有 `datetime_tool_match`？
- 日志中是否有 `task_analyzer_tools_executed`？
- 返回的时间时区是否正确？

---

### 测试用例 3: 时区配置验证

**场景**: 用户时区设置为 `Asia/Taipei`

**预期结果**：

- ✅ 配置读取成功
- ✅ 时区转换为 `Asia/Taipei`
- ✅ 返回的时间是 `Asia/Taipei` 时区

**验证点**：

- 日志中是否有 `datetime_config_read`？
- 日志中 `default_timezone` 是否为 `Asia/Taipei`？
- 日志中 `target_timezone` 是否为 `Asia/Taipei`？

---

## 📚 相关文档

- [GenAI 工作流程追踪](../系统设计文档/核心组件/GenAI工作流指令-語義-工具-模型-Agent等調用.md)
- [问题诊断：时间查询应该使用 datetime 工具](./问题诊断-时间查询应该使用datetime工具.md)
- [工具 API 文档](../系统设计文档/tools/工具API文档.md)
- [工具组开发规格](../系统设计文档/tools/工具組開發規格.md)

---

---

## ✅ 已修复问题（2026-01-06）

### 修复：时间工具自动使用系统时区

**问题**：时间工具默认使用 UTC，而不是系统时区。

**解决方案**：

1. ✅ 添加 `_get_system_timezone()` 方法，自动检测系统时区
2. ✅ 修改 `_get_default_config()`，使用系统时区作为默认值
3. ✅ 修改时区确定逻辑，优先级：用户指定 > 配置 > 系统时区 > UTC

**效果**：

- 如果用户没有配置时区，时间工具会自动使用服务器时区（如 `Asia/Taipei`）
- 不再需要手动配置时区，系统会自动判断

---

**最後更新日期**: 2026-01-06
**文檔版本**: 1.1
**維護人**: Daniel Chung
