# 代碼質量問題分析與解決方案

**版本**: 1.0
**創建日期**: 2025-01-27
**創建人**: Daniel Chung
**最後修改日期**: 2025-01-27

---

## 問題概述

在開發過程中，經常會遇到 `ruff` 和 `mypy` 檢查不通過的問題。根據當前項目的統計數據：

- **F841 (未使用的變量)**: 28 個
- **E402 (導入不在文件頂部)**: 15 個
- **F821 (未定義的名稱)**: 5 個
- **E722 (裸 except)**: 2 個

## 為什麼會發生這些問題？

### 1. **AI 生成代碼時的問題**

#### 問題 1: 未使用的變量 (F841)

**原因**：

- AI 生成代碼時，可能會創建臨時變量用於調試或測試
- 代碼重構時，某些變量被替換但舊的賦值語句沒有刪除
- 函數返回值被賦值但後續沒有使用

**常見場景**：

```python
# ❌ 錯誤：變量被賦值但未使用
def process_file(file_id: str):
    result = some_service.process(file_id)  # 賦值但未使用
    return {"status": "ok"}

# ✅ 正確：如果不需要返回值，直接調用
def process_file(file_id: str):
    some_service.process(file_id)
    return {"status": "ok"}

# ✅ 正確：如果需要返回值，使用它
def process_file(file_id: str):
    result = some_service.process(file_id)
    logger.info(f"處理結果: {result}")
    return {"status": "ok", "result": result}
```

#### 問題 2: 導入不在文件頂部 (E402)

**原因**：

- AI 生成代碼時，可能會在函數內部或條件語句中導入模塊
- 為了避免循環導入，開發者可能會將導入放在函數內部
- 動態導入（在運行時根據條件導入）導致導入不在頂部

**常見場景**：

```python
# ❌ 錯誤：導入在函數內部
def process_data():
    import pandas as pd  # 應該在文件頂部
    return pd.DataFrame()

# ✅ 正確：所有導入在文件頂部
import pandas as pd

def process_data():
    return pd.DataFrame()

# ✅ 正確：如果必須動態導入，使用類型忽略
def process_data():
    import pandas as pd  # type: ignore[E402]
    return pd.DataFrame()
```

#### 問題 3: 未定義的名稱 (F821)

**原因**：

- AI 生成代碼時，可能會引用不存在的變量或函數
- 代碼重構時，變量名被修改但引用處沒有更新
- 作用域問題：變量在一個作用域定義，但在另一個作用域使用

**常見場景**：

```python
# ❌ 錯誤：變量未定義
def process_file(file_id: str):
    if some_condition:
        result = process(file_id)
    return result  # result 可能未定義

# ✅ 正確：確保變量在所有路徑都有定義
def process_file(file_id: str):
    result = None
    if some_condition:
        result = process(file_id)
    return result
```

#### 問題 4: 裸 except (E722)

**原因**：

- AI 生成代碼時，為了快速處理異常，可能會使用 `except:` 而不是 `except Exception:`
- 開發者可能不知道應該捕獲具體的異常類型

**常見場景**：

```python
# ❌ 錯誤：裸 except
try:
    result = risky_operation()
except:  # 會捕獲所有異常，包括 SystemExit 和 KeyboardInterrupt
    logger.error("操作失敗")

# ✅ 正確：捕獲具體的異常類型
try:
    result = risky_operation()
except Exception as e:  # 只捕獲 Exception 及其子類
    logger.error(f"操作失敗: {e}")
```

### 2. **代碼修改時的問題**

#### 問題 1: 類型注解不完整

**原因**：

- 修改代碼時，忘記更新類型注解
- 新增參數時，沒有添加類型注解
- 函數返回值類型改變，但類型注解沒有更新

**常見場景**：

```python
# ❌ 錯誤：缺少類型注解
def process_data(data):
    return data.get("result")

# ✅ 正確：完整的類型注解
def process_data(data: Dict[str, Any]) -> Optional[str]:
    return data.get("result")
```

#### 問題 2: 模塊路徑衝突 (mypy)

**原因**：

- 項目結構變更時，模塊路徑沒有同步更新
- 同一個文件可以通過不同的路徑導入（如 `api.middleware.prometheus` 和 `services.api.middleware.prometheus`）

**常見場景**：

```python
# 問題：同一個文件可以通過不同路徑導入
from api.middleware.prometheus import PrometheusMiddleware
from services.api.middleware.prometheus import PrometheusMiddleware  # 同一個文件

# 解決方案：統一導入路徑，或配置 mypy 忽略
```

## 如何避免這些問題？

### 1. **開發時的最佳實踐**

#### ✅ 使用 IDE 的實時檢查

配置 IDE（如 VS Code、PyCharm）啟用實時類型檢查和 linting：

**VS Code 設置**：

```json
{
  "python.linting.enabled": true,
  "python.linting.ruffEnabled": true,
  "python.linting.mypyEnabled": true,
  "python.analysis.typeCheckingMode": "basic"
}
```

#### ✅ 在編寫代碼時運行檢查

**開發流程**：

1. 編寫代碼
2. 保存文件時自動運行 `ruff check --fix`
3. 提交前運行 `mypy .` 檢查類型

**快捷命令**：

```bash
# 自動修復可修復的問題
ruff check --fix .

# 檢查類型
mypy .

# 檢查特定文件
ruff check path/to/file.py
mypy path/to/file.py
```

#### ✅ 遵循項目規範

嚴格遵循 `.cursor/rules/develop-rule.mdc` 中的規範：

1. **類型注解規範**：
   - 所有函數參數和返回值必須有類型注解
   - 全局變量必須有類型注解
   - 可能為 None 的變量使用 `Optional[T]`

2. **代碼結構規範**：
   - 所有 import 必須在文件頂部
   - 使用標準庫、第三方庫、本地模塊的順序

3. **防御性編程規範**：
   - 使用前檢查 None
   - 使用具體的異常類型，避免裸 except

### 2. **AI 生成代碼時的指導原則**

#### ✅ 明確要求類型注解

在提示詞中明確要求：

```
請生成包含完整類型注解的 Python 代碼：
- 所有函數參數必須有類型注解
- 所有返回值必須有類型注解
- 可能為 None 的變量使用 Optional[T]
```

#### ✅ 要求遵循項目規範

在提示詞中引用項目規範：

```
請遵循項目的開發規範：
- 所有 import 必須在文件頂部
- 使用 Optional[T] 而不是 T = None
- 使用 except Exception 而不是裸 except
- 所有變量必須被使用，不要創建未使用的變量
```

#### ✅ 生成後立即檢查

AI 生成代碼後，立即運行檢查：

```bash
ruff check --fix path/to/new_file.py
mypy path/to/new_file.py
```

### 3. **代碼審查檢查清單**

在提交代碼前，檢查以下項目：

- [ ] 所有類型注解完整且正確
- [ ] 所有 import 在文件頂部
- [ ] 沒有未使用的變量
- [ ] 沒有未定義的名稱
- [ ] 沒有裸 except
- [ ] 通過 `ruff check .`
- [ ] 通過 `mypy .`

### 4. **自動化工具配置**

#### ✅ 配置 pre-commit hooks

`.pre-commit-config.yaml` 已經配置了自動檢查，但需要確保：

1. **所有開發者都安裝了 pre-commit**：

   ```bash
   pip install pre-commit
   pre-commit install
   ```

2. **提交前自動運行檢查**：

   ```bash
   git commit -m "your message"  # 會自動運行檢查
   ```

#### ✅ 配置 CI/CD

在 CI/CD 流程中強制檢查：

```yaml
# .github/workflows/ci.yml
- name: Run ruff
  run: ruff check .

- name: Run mypy
  run: mypy .
```

## 常見錯誤模式與修復方法

### 模式 1: 未使用的變量

**錯誤**：

```python
def process_file(file_id: str):
    result = some_service.process(file_id)  # F841
    return {"status": "ok"}
```

**修復**：

```python
# 方法 1: 如果不需要返回值，直接調用
def process_file(file_id: str):
    some_service.process(file_id)
    return {"status": "ok"}

# 方法 2: 如果需要返回值，使用它
def process_file(file_id: str):
    result = some_service.process(file_id)
    logger.info(f"處理結果: {result}")
    return {"status": "ok", "result": result}
```

### 模式 2: 導入不在頂部

**錯誤**：

```python
def process_data():
    import pandas as pd  # E402
    return pd.DataFrame()
```

**修復**：

```python
# 方法 1: 將導入移到文件頂部
import pandas as pd

def process_data():
    return pd.DataFrame()

# 方法 2: 如果必須動態導入，使用類型忽略
def process_data():
    import pandas as pd  # type: ignore[E402]
    return pd.DataFrame()
```

### 模式 3: 未定義的名稱

**錯誤**：

```python
def process_file(file_id: str):
    if some_condition:
        result = process(file_id)
    return result  # F821: result 可能未定義
```

**修復**：

```python
def process_file(file_id: str):
    result = None  # 初始化變量
    if some_condition:
        result = process(file_id)
    return result
```

### 模式 4: 裸 except

**錯誤**：

```python
try:
    result = risky_operation()
except:  # E722
    logger.error("操作失敗")
```

**修復**：

```python
try:
    result = risky_operation()
except Exception as e:  # 捕獲具體異常
    logger.error(f"操作失敗: {e}")
```

### 模式 5: 類型注解不完整

**錯誤**：

```python
def process_data(data):
    return data.get("result")
```

**修復**：

```python
from typing import Dict, Any, Optional

def process_data(data: Dict[str, Any]) -> Optional[str]:
    return data.get("result")
```

## 總結

### 問題根源

1. **AI 生成代碼時**：
   - 沒有嚴格遵循類型注解規範
   - 創建了未使用的變量
   - 導入語句位置不當

2. **代碼修改時**：
   - 忘記更新類型注解
   - 沒有同步更新相關引用
   - 沒有運行檢查工具

3. **缺乏實時檢查**：
   - IDE 沒有配置實時檢查
   - 開發時沒有運行檢查工具
   - 依賴提交時的 pre-commit hooks

### 解決方案

1. **開發時**：
   - ✅ 配置 IDE 實時檢查
   - ✅ 保存時自動運行 `ruff check --fix`
   - ✅ 提交前運行 `mypy .`

2. **AI 生成代碼時**：
   - ✅ 明確要求類型注解
   - ✅ 引用項目規範
   - ✅ 生成後立即檢查

3. **代碼審查時**：
   - ✅ 使用檢查清單
   - ✅ 確保所有檢查通過
   - ✅ 修復所有警告

4. **自動化**：
   - ✅ 配置 pre-commit hooks
   - ✅ 配置 CI/CD 檢查
   - ✅ 強制執行規範

---

**文檔版本**: 1.0
**最後更新**: 2025-01-27
**維護者**: Daniel Chung
