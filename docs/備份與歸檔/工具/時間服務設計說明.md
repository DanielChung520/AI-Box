# 時間服務設計說明

**創建日期**: 2025-12-30
**創建人**: Daniel Chung
**最後修改日期**: 2025-12-30

**關聯文檔**: [工具組開發規格](./工具組開發規格.md)、[工具組需求分析](./工具組需求分析.md)

---

## 📋 設計概述

### 需求背景

在 AI-Box 系統中，需要一個高精度、可靠的時間服務，用於：

1. **Agent 任務調度**：需要準確的時間來處理時間相關的任務
2. **日誌記錄**：需要高精度時間戳來追蹤操作順序
3. **時間敏感操作**：某些操作對時間精度要求很高

### 設計目標

1. **高精度**：使用 `time.perf_counter()` 提供高精度時間，避免系統時間調整導致的時間跳躍
2. **性能優化**：使用緩存機制減少系統調用開銷
3. **簡單實用**：無需複雜的同步策略，足夠好的設計

---

## 🏗️ 架構設計

### 核心組件

```
TimeService
├── 緩存時間（_cached_time）
├── 最後更新時間（_last_update，使用 perf_counter）
└── 緩存持續時間（_cache_duration，默認 100ms）
```

### 工作原理

1. **初始化**：記錄當前系統時間和 `perf_counter` 值
2. **獲取時間**：
   - 計算自上次更新以來經過的時間（使用 `perf_counter`）
   - 如果經過時間 > 緩存持續時間（100ms），更新系統時間
   - 返回：`緩存時間 + 經過時間`

### 時間獲取流程

```
用戶調用 now()
    ↓
計算：elapsed = perf_counter() - _last_update
    ↓
如果 elapsed > cache_duration:
    更新 _cached_time = time.time()
    更新 _last_update = perf_counter()
    elapsed = 0.0
    ↓
返回：_cached_time + elapsed
```

---

## 🔧 實現細節

### 核心方法

#### `now() -> float`

獲取當前時間（Unix 時間戳），使用緩存機制：

```python
def now(self) -> float:
    with self._lock:
        elapsed = time.perf_counter() - self._last_update

        if elapsed > self._cache_duration:
            self._cached_time = time.time()
            self._last_update = time.perf_counter()
            elapsed = 0.0

        return self._cached_time + elapsed
```

#### `now_datetime() -> datetime`

獲取當前時間（datetime 對象，本地時區）：

```python
def now_datetime(self) -> datetime:
    return datetime.fromtimestamp(self.now())
```

#### `now_utc_datetime() -> datetime`

獲取當前時間（UTC datetime 對象）：

```python
def now_utc_datetime(self) -> datetime:
    return datetime.utcfromtimestamp(self.now())
```

---

## 📊 性能特點

### 優勢

1. **減少系統調用**：
   - 每 100ms 才調用一次 `time.time()`
   - 大幅減少系統調用開銷

2. **高精度**：
   - 使用 `time.perf_counter()` 提供微秒級精度
   - 避免系統時間調整導致的時間跳躍

3. **線程安全**：
   - 使用 Lock 保護共享狀態
   - 支持多線程環境下的安全使用

### 性能對比

| 方案 | 系統調用頻率 | 精度 | 複雜度 |
|------|------------|------|--------|
| 直接調用 `time.time()` | 每次調用 | 毫秒級 | 低 |
| **TimeService（緩存 100ms）** | **每 100ms** | **微秒級** | **低** |
| 複雜方案（NTP 同步） | 每 5 秒 + NTP | 微秒級 | 高 |

---

## ⚙️ 配置參數

### 可配置參數

| 參數 | 默認值 | 說明 |
|------|--------|------|
| `cache_duration` | 0.1 | 緩存持續時間（秒），默認 0.1 秒（100ms） |

### 配置建議

- **100ms（默認）**：適合大多數場景，平衡性能和精度
- **50ms**：需要更高精度時使用，但系統調用更頻繁
- **200ms**：性能優先，但精度略低

---

## 🔍 使用示例

### 基本使用

```python
from tools.time.smart_time_service import get_time_service

# 獲取服務實例（單例模式）
time_service = get_time_service()

# 獲取當前時間
current_time = time_service.now()  # Unix 時間戳
current_datetime = time_service.now_datetime()  # datetime 對象（本地時區）
current_utc_datetime = time_service.now_utc_datetime()  # UTC datetime 對象

print(f"Current time: {current_datetime}")
print(f"Unix timestamp: {current_time:.6f}")
```

### 自定義緩存時間

```python
from tools.time.smart_time_service import TimeService

# 創建自定義緩存時間的實例（50ms）
time_service = TimeService(cache_duration=0.05)
current_time = time_service.now()
```

### 在 DateTimeTool 中使用

```python
from tools.time.smart_time_service import get_time_service
from tools.time.datetime_tool import DateTimeTool

# DateTimeTool 內部使用 TimeService
time_service = get_time_service()
current_time = time_service.now()

# 格式化時間
tool = DateTimeTool()
result = await tool.execute(DateTimeInput(
    timezone="Asia/Taipei",
    format="%Y-%m-%d %H:%M:%S"
))
```

---

## 🧪 測試建議

### 單元測試

1. **時間獲取測試**：驗證 `now()` 返回的時間是否準確
2. **緩存機制測試**：驗證緩存是否正常工作（快速調用時不更新系統時間）
3. **精度測試**：驗證時間精度是否達到微秒級
4. **線程安全測試**：驗證多線程環境下的安全性

### 性能測試

1. **系統調用頻率測試**：驗證緩存機制是否減少系統調用
2. **並發性能測試**：驗證多線程環境下的性能

---

## 📝 依賴要求

### 必需依賴

- Python 3.11+
- `structlog`: 用於日誌記錄（項目已有）

### 無額外依賴

TimeService 僅使用 Python 標準庫：

- `time`: 時間相關功能
- `datetime`: 日期時間對象
- `threading`: 線程安全（Lock）

**注意**：無需 `ntplib` 或其他外部依賴。

---

## 🔗 相關文檔

- [工具組開發規格](./工具組開發規格.md) - 完整的工具組技術規格
- [工具組需求分析](./工具組需求分析.md) - 工具組功能需求和使用場景
- [System Config 存儲位置說明](./System-Config-存储位置说明.md) - 配置存儲說明

---

## 💡 設計決策

### 為什麼選擇緩存機制而不是 NTP 同步？

1. **簡單實用**：緩存機制足夠滿足大多數場景的需求
2. **性能優化**：減少系統調用，提高性能
3. **無外部依賴**：不需要 NTP 服務器，無需額外依賴
4. **足夠好的設計**：符合 "足夠好" 的設計原則，避免過度設計

### 為什麼選擇 100ms 緩存時間？

1. **平衡性能和精度**：100ms 對於大多數應用場景已經足夠
2. **減少系統調用**：相比每次調用 `time.time()`，減少 90%+ 的系統調用
3. **高精度**：使用 `perf_counter` 仍然提供微秒級精度

---

**最後更新**: 2025-12-30
**維護人**: Daniel Chung
