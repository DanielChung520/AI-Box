# 文件上傳後的任務工作區處理邏輯確認

**創建日期**: 2025-01-27  
**創建人**: Daniel Chung  
**最後修改日期**: 2025-01-27

## 修改摘要

已實現文件上傳時的任務工作區自動創建和文件位置管理邏輯。

---

## 實現邏輯

### 1. 當提供 task_id 時（新任務或已存在任務）

**流程**：
```
提供 task_id
    ↓
檢查任務是否存在（UserTaskService.get()）
    ↓
┌─────────────────┬─────────────────┐
│  任務不存在      │   任務已存在     │
└─────────────────┴─────────────────┘
    ↓                    ↓
自動創建新任務      使用現有任務
    ↓                    ↓
創建任務工作區      使用現有任務工作區
    ↓                    ↓
文件放在任務工作區下 ←──┘
```

**代碼位置**：`api/routers/file_upload.py` 第 646-700 行

**關鍵邏輯**：
- ✅ 檢查任務是否存在
- ✅ 如果不存在，自動創建新任務（包含任務工作區）
- ✅ 如果已存在，直接使用該任務的任務工作區
- ✅ 文件元數據的 `task_id` 字段設置為該任務的 `task_id`
- ✅ 文件位置在該任務的任務工作區下

### 2. 當沒有提供 task_id 時

**流程**：
```
未提供 task_id
    ↓
使用 "temp-workspace"（臨時工作區）
    ↓
文件放在臨時工作區下
```

**代碼位置**：`api/routers/file_upload.py` 第 755 行

**關鍵邏輯**：
- ✅ 使用 `"temp-workspace"` 作為默認 task_id
- ✅ 文件元數據的 `task_id` 字段設置為 `"temp-workspace"`
- ✅ 文件位置在臨時工作區下

---

## 任務工作區概念

### 定義

- **task_id** 就是任務工作區的標識符
- 文件通過 `task_id` 關聯到任務工作區
- 在文件樹中，`task_id` 對應一個任務節點
- 文件元數據中的 `task_id` 字段表示文件所在的工作區

### 工作區類型

1. **任務工作區**（有對應的任務）
   - `task_id` 對應一個實際的任務記錄
   - 任務記錄存儲在 ArangoDB `user_tasks` 集合
   - 文件通過 `task_id` 關聯到該任務工作區

2. **臨時工作區**（沒有對應的任務）
   - `task_id = "temp-workspace"`
   - 沒有對應的任務記錄
   - 用於存放未指定任務的文件

---

## 文件位置確認

### 文件實體存儲

- **位置**: 本地文件系統
- **路徑結構**: `./data/datasets/files/{file_id前兩個字符}/{file_id}.{ext}`
- **組織方式**: 按 `file_id` 組織，不直接按 `task_id` 組織

### 文件元數據

- **位置**: ArangoDB `file_metadata` 集合
- **關鍵字段**: `task_id`（表示文件所在的工作區）
- **關聯方式**: 通過 `task_id` 字段關聯到任務工作區

### 文件樹顯示

- **組織方式**: 按 `task_id` 分組
- **顯示邏輯**: 
  - 每個 `task_id` 對應一個任務節點
  - 該任務節點下的所有文件（`task_id` 匹配）顯示在該節點下
  - `"temp-workspace"` 作為臨時工作區節點顯示

---

## 代碼修改詳情

### 修改文件

`api/routers/file_upload.py`

### 修改內容

#### 1. 添加導入（第 47-48 行）

```python
from services.api.services.user_task_service import get_user_task_service
from services.api.models.user_task import UserTaskCreate
```

#### 2. 添加任務檢查和自動創建邏輯（第 646-700 行）

```python
# 修改時間：2025-01-27 - 實現任務工作區自動創建邏輯
# 如果提供了 task_id，檢查任務是否存在，如果不存在則自動創建
if task_id:
    task_service = get_user_task_service()
    existing_task = task_service.get(
        user_id=current_user.user_id,
        task_id=task_id,
    )
    
    if existing_task is None:
        # 任務不存在，自動創建新任務及任務工作區
        # ... 創建邏輯 ...
    else:
        # 任務已存在，直接使用該任務的任務工作區
        # ... 使用邏輯 ...
```

#### 3. 更新文件元數據創建邏輯（第 752-765 行）

```python
# 修改時間：2025-01-27 - 確保文件放在任務工作區下
# 如果提供了 task_id，使用該 task_id（任務工作區已在上方確保存在）
# 如果未提供 task_id，使用 "temp-workspace"（臨時工作區）
final_task_id = task_id or "temp-workspace"

# 確保文件放在任務工作區下（task_id 就是任務工作區的標識）
metadata_create = FileMetadataCreate(
    # ...
    task_id=final_task_id,  # 文件位置在該任務的任務工作區下
)
```

---

## 測試建議

### 測試場景 1：新任務上傳

1. 提供一個不存在的 `task_id`
2. 上傳文件
3. **預期結果**：
   - ✅ 自動創建新任務
   - ✅ 任務工作區自動創建
   - ✅ 文件元數據的 `task_id` 為提供的 `task_id`
   - ✅ 文件顯示在該任務的任務工作區下

### 測試場景 2：已存在任務上傳

1. 提供一個已存在的 `task_id`
2. 上傳文件
3. **預期結果**：
   - ✅ 不創建新任務
   - ✅ 使用現有任務的任務工作區
   - ✅ 文件元數據的 `task_id` 為提供的 `task_id`
   - ✅ 文件顯示在該任務的任務工作區下

### 測試場景 3：無 task_id 上傳

1. 不提供 `task_id`
2. 上傳文件
3. **預期結果**：
   - ✅ 使用 `"temp-workspace"` 作為 task_id
   - ✅ 文件元數據的 `task_id` 為 `"temp-workspace"`
   - ✅ 文件顯示在臨時工作區下

---

## 確認清單

- [x] ✅ 當提供 task_id 時，檢查任務是否存在
- [x] ✅ 如果任務不存在，自動創建新任務及任務工作區
- [x] ✅ 如果任務已存在，直接使用該任務的任務工作區
- [x] ✅ 文件放在任務工作區下（通過 task_id 關聯）
- [x] ✅ 當沒有提供 task_id 時，使用 "temp-workspace"
- [x] ✅ 所有變量名已更新（default_task_id → final_task_id）
- [x] ✅ 代碼邏輯完整且正確
- [x] ✅ 添加了適當的日誌記錄

---

## 注意事項

1. **任務創建失敗處理**：
   - 如果任務創建失敗，仍會使用該 `task_id` 作為文件的 `task_id`
   - 文件仍會關聯到該任務工作區，但任務記錄可能不存在
   - 建議前端在任務創建失敗時提示用戶

2. **任務標題**：
   - 自動創建的任務使用默認標題：`"任務 {task_id}"`
   - 建議前端後續允許用戶修改任務標題

3. **權限檢查**：
   - 任務創建後會檢查任務文件訪問權限
   - 確保用戶有權限上傳文件到該任務

---

## 總結

✅ **已實現**：文件上傳時的任務工作區自動創建和文件位置管理邏輯

✅ **符合需求**：
1. 當為新任務時，創建新任務及該任務的『任務工作區』，並且將檔案位置在該任務的『任務工作區』的下方
2. 當在已經存在，則直接在該任務的『任務工作區』，並且將檔案位置在該任務的『任務工作區』的下方

✅ **文件位置**：
- 文件實體：本地文件系統（按 file_id 組織）
- 文件元數據：ArangoDB（包含 task_id 字段）
- 文件關聯：通過 task_id 關聯到任務工作區
- 文件顯示：按 task_id 分組顯示在對應的任務工作區下

