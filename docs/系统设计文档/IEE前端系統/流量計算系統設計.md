# AI-Box æµé‡è¨ˆç®—ç³»çµ±è¨­è¨ˆ

**æ–‡æª”ç‰ˆæœ¬**: v1.0  
**å‰µå»ºæ—¥æœŸ**: 2026-01-24  
**æœ€å¾Œæ›´æ–°**: 2026-01-24  
**é©ç”¨å ´æ™¯**: AI-Box ç³»çµ±çš„æµé‡ç›£æ§ã€è³‡æºç®¡ç†å’Œæˆæœ¬æ§åˆ¶

---

## ğŸ“‹ ç›®éŒ„

- [1. æ¦‚è¿°](#1-æ¦‚è¿°)
- [2. ç³»çµ±æ¶æ§‹](#2-ç³»çµ±æ¶æ§‹)
- [3. æ•¸æ“šæ¨¡å‹è¨­è¨ˆ](#3-æ•¸æ“šæ¨¡å‹è¨­è¨ˆ)
- [4. æµé‡è¨ˆç®—é‚è¼¯](#4-æµé‡è¨ˆç®—é‚è¼¯)
- [5. æˆæœ¬è¨ˆç®—æ¨¡å‹](#5-æˆæœ¬è¨ˆç®—æ¨¡å‹)
- [6. ç›£æ§å’Œå ±å‘Š](#6-ç›£æ§å’Œå ±å‘Š)
- [7. API è¨­è¨ˆ](#7-api-è¨­è¨ˆ)
- [8. å‰ç«¯é›†æˆ](#8-å‰ç«¯é›†æˆ)
- [9. å¯¦ç¾è¨ˆåŠƒ](#9-å¯¦ç¾è¨ˆåŠƒ)

---

## 1. æ¦‚è¿°

### 1.1 ç›®çš„

å»ºç«‹å…¨é¢çš„æµé‡è¨ˆç®—å’Œç›£æ§ç³»çµ±ï¼Œå¯¦ç¾ä»¥ä¸‹ç›®æ¨™ï¼š

- **ç”¨æˆ¶ä½¿ç”¨é‡çµ±è¨ˆ**: ç²¾ç¢ºè¨˜éŒ„å’Œçµ±è¨ˆæ¯å€‹ç”¨æˆ¶çš„ API ä½¿ç”¨æƒ…æ³
- **è³‡æºç®¡ç†å’Œå„ªåŒ–**: å¯¦æ™‚ç›£æ§è³‡æºä½¿ç”¨ï¼Œå‹•æ…‹å„ªåŒ–åˆ†é…
- **ç”¨æˆ¶è¡Œç‚ºåˆ†æ**: åˆ†æä½¿ç”¨æ¨¡å¼ï¼Œå„ªåŒ–æœå‹™é«”é©—
- **ç³»çµ±å®¹é‡è¦åŠƒ**: åŸºæ–¼æµé‡é æ¸¬é€²è¡Œæ“´å®¹è¦åŠƒ
- **æˆæœ¬æ§åˆ¶å’Œè¨ˆè²»**: æº–ç¢ºè¨ˆç®—å’Œæ§åˆ¶ä½¿ç”¨æˆæœ¬

### 1.2 æ ¸å¿ƒåŠŸèƒ½

| åŠŸèƒ½æ¨¡å¡Š | èªªæ˜ | å„ªå…ˆç´š |
|----------|------|--------|
| **Token è¨ˆè²»** | è¨ˆç®—æ¯æ¬¡ API èª¿ç”¨çš„è¼¸å…¥/è¼¸å‡º tokens | ğŸ”´ é«˜ |
| **ç”¨æˆ¶ä½¿ç”¨çµ±è¨ˆ** | çµ±è¨ˆå°è©±æ¬¡æ•¸ã€æ¨¡å‹ä½¿ç”¨åˆ†å¸ƒ | ğŸ”´ é«˜ |
| **è³‡æºç›£æ§** | å¯¦æ™‚ç›£æ§ CPUã€å…§å­˜ã€API èª¿ç”¨ | ğŸŸ  ä¸­ |
| **æˆæœ¬å ±å‘Š** | æŒ‰ç”¨æˆ¶/æ™‚é–“æ®µç”Ÿæˆæˆæœ¬å ±å‘Š | ğŸŸ  ä¸­ |
| **é…é¡ç®¡ç†** | ç”¨æˆ¶ç´šåˆ¥çš„æµé‡é™åˆ¶å’Œé…é¡ | ğŸŸ  ä¸­ |
| **é è­¦ç³»çµ±** | è¶…å‡ºé–¾å€¼æ™‚è‡ªå‹•ç™¼é€é è­¦ | ğŸŸ¡ ä½ |

---

## 2. ç³»çµ±æ¶æ§‹

### 2.1 æ¶æ§‹åœ–

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   AI-Box æµé‡è¨ˆç®—ç³»çµ±                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                â”‚                â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
   â”‚ API Gate â”‚    â”‚ Collector  â”‚   â”‚ Storage â”‚
   â”‚  way    â”‚    â”‚  Service  â”‚   â”‚ Service â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
        â”‚                â”‚                â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚    Usage Analytics  â”‚
              â”‚      Service        â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                â”‚                â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
   â”‚ Costing  â”‚    â”‚ Reporting  â”‚   â”‚ Alerting  â”‚
   â”‚ Service â”‚    â”‚  Service   â”‚   â”‚ Service   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ•¸æ“šæµç¨‹

```
1. æ•¸æ“šæ”¶é›†éšæ®µ
   API Gateway æ‹¦æˆªæ‰€æœ‰ LLM API èª¿ç”¨
   â†“
   è¨˜éŒ„è«‹æ±‚/éŸ¿æ‡‰å…ƒæ•¸æ“š
   â†“
   ç™¼é€åˆ°æ”¶é›†æœå‹™

2. è™•ç†éšæ®µ
   Collector Service æ¥æ”¶ä¸¦è™•ç†æ•¸æ“š
   â†“
   è¨ˆç®— tokensã€æˆæœ¬ã€ä½¿ç”¨æŒ‡æ¨™
   â†“
   å­˜å„²åˆ°æ•¸æ“šåº«

3. åˆ†æéšæ®µ
   Usage Analytics Service é€²è¡Œèšåˆåˆ†æ
   â†“
   ç”Ÿæˆçµ±è¨ˆå ±å‘Šå’ŒæŒ‡æ¨™

4. æ‡‰ç”¨éšæ®µ
   Costing Service é€²è¡Œæˆæœ¬è¨ˆç®—
   â†“
   Reporting Service ç”Ÿæˆå¯è¦–åŒ–å ±å‘Š
   â†“
   Alerting Service ç›£æ§é è­¦
```

---

## 3. æ•¸æ“šæ¨¡å‹è¨­è¨ˆ

### 3.1 æ ¸å¿ƒæ•¸æ“šå¯¦é«”

#### ğŸ”¢ **API Usage Log (API ä½¿ç”¨æ—¥èªŒ)**

```python
{
  "_key": "usage_log_20260124_001",
  "timestamp": "2026-01-24T10:30:00.000Z",
  "user_id": "user_123",
  "tenant_id": "tenant_456",
  "session_id": "session_789",
  
  "request_info": {
    "request_id": "req_123456",
    "model": "smartq-hci",
    "actual_model_used": "gpt-oss:120b-cloud",
    "scene": "chat",
    "provider": "ollama",
    "endpoint": "/api/v1/chat"
  },
  
  "usage_metrics": {
    "input_tokens": 150,
    "output_tokens": 300,
    "total_tokens": 450,
    "response_time_ms": 1250,
    "status_code": 200,
    "success": true
  },
  
  "cost_info": {
    "cost_per_1k_input": 0.00015,
    "cost_per_1k_output": 0.0006,
    "total_cost": 0.0002025
  },
  
  "routing_info": {
    "primary_model": "gpt-oss:120b-cloud",
    "fallback_used": false,
    "routing_decision": "performance_based"
  }
}
```

#### ğŸ“Š **Daily Usage Summary (æ¯æ—¥ä½¿ç”¨æ‘˜è¦)**

```python
{
  "_key": "daily_summary_20260124_user123",
  "date": "2026-01-24",
  "user_id": "user_123",
  "tenant_id": "tenant_456",
  
  "conversation_stats": {
    "total_conversations": 15,
    "total_messages": 45,
    "avg_response_time_ms": 1380,
    "success_rate": 0.97
  },
  
  "model_usage": {
    "smartq-hci": {
      "calls": 8,
      "tokens_used": 3200,
      "cost": 0.64
    },
    "chatgpt-latest": {
      "calls": 5,
      "tokens_used": 2500,
      "cost": 0.75
    },
    "gemini-latest": {
      "calls": 2,
      "tokens_used": 800,
      "cost": 0.12
    }
  },
  
  "total_metrics": {
    "total_calls": 15,
    "total_tokens": 6500,
    "total_cost": 1.51,
    "peak_concurrent_calls": 3
  }
}
```

#### ğŸ’° **User Quota (ç”¨æˆ¶é…é¡)**

```python
{
  "_key": "quota_user123",
  "user_id": "user_123",
  "tenant_id": "tenant_456",
  
  "quota_limits": {
    "daily_tokens": 100000,
    "daily_api_calls": 100,
    "monthly_cost_limit": 50.0,
    "concurrent_calls": 5
  },
  
  "current_usage": {
    "daily_tokens_used": 23450,
    "daily_api_calls": 23,
    "monthly_cost": 1.51,
    "current_concurrent": 2
  },
  
  "usage_percentages": {
    "daily_tokens": 23.45,
    "daily_api_calls": 23.0,
    "monthly_cost": 3.02
  },
  
  "reset_times": {
    "daily_reset": "2026-01-25T00:00:00.000Z",
    "monthly_reset": "2026-02-01T00:00:00.000Z"
  }
}
```

### 3.2 ArangoDB é›†åˆè¨­è¨ˆ

#### ğŸ—„ï¸ **æ•¸æ“šåº«çµæ§‹**

```python
# æµé‡ç›¸é—œé›†åˆ
collections = {
    "api_usage_logs": "API ä½¿ç”¨æ—¥èªŒï¼ˆåŸå§‹æ•¸æ“šï¼‰",
    "daily_usage_summaries": "æ¯æ—¥ä½¿ç”¨æ‘˜è¦ï¼ˆèšåˆæ•¸æ“šï¼‰",
    "user_quotas": "ç”¨æˆ¶é…é¡",
    "cost_records": "æˆæœ¬è¨˜éŒ„",
    "usage_alerts": "ä½¿ç”¨é è­¦"
}

# ç´¢å¼•è¨­è¨ˆ
indexes = {
    "api_usage_logs": [
        {"type": "persistent", "fields": ["user_id", "timestamp"]},
        {"type": "persistent", "fields": ["tenant_id", "timestamp"]},
        {"type": "persistent", "fields": ["model", "timestamp"]}
    ],
    "daily_usage_summaries": [
        {"type": "persistent", "fields": ["date", "user_id"]},
        {"type": "persistent", "fields": ["tenant_id", "date"]}
    ]
}
```

---

## 4. æµé‡è¨ˆç®—é‚è¼¯

### 4.1 Token è¨ˆç®—

#### ğŸ§® **è¼¸å…¥ Tokens è¨ˆç®—**

```python
def calculate_input_tokens(messages: List[Dict]) -> int:
    """
    è¨ˆç®—è¼¸å…¥ tokens
    
    è¨ˆç®—æ–¹å¼ï¼š
    1. æ™ºèƒ½ä¼°è¨ˆï¼šä½¿ç”¨æ¨¡å‹ç‰¹å®šçš„ token ä¼°è¨ˆ
    2. æ¨¡å‹ç´šåˆ¥ï¼šæ ¹æ“šæ¨¡å‹ç²¾åº¦èª¿æ•´
    """
    total_tokens = 0
    
    for message in messages:
        content = message.get("content", "")
        role = message.get("role", "")
        
        # æ ¹æ“šæ¨¡å‹é¸æ“‡ä¸åŒçš„è¨ˆç®—æ–¹æ³•
        if model.startswith("gpt-"):
            # GPT ç³»åˆ—ï¼š~4 chars per token
            tokens = len(content) // 4
        elif model.startswith("gemini-"):
            # Gemini ç³»åˆ—ï¼š~4 chars per token
            tokens = len(content) // 4
        elif model.startswith("qwen-") or model.startswith("glm-"):
            # Qwen/GLM ç³»åˆ—ï¼š~1.5 chars per tokenï¼ˆä¸­æ–‡æ›´é«˜æ•ˆï¼‰
            chinese_chars = len([c for c in content if '\u4e00' <= c <= '\u9fff'])
            tokens = chinese_chars * 2 + (len(content) - chinese_chars) // 2
        else:
            # é»˜èªï¼š~4 chars per token
            tokens = len(content) // 4
        
        # ç³»çµ±æ¶ˆæ¯è¨ˆæ¬Šé‡æ¸›åŠ
        if role == "system":
            tokens = tokens // 2
        
        total_tokens += tokens
    
    return total_tokens
```

#### ğŸ“ **è¼¸å‡º Tokens è¨ˆç®—**

```python
def calculate_output_tokens(response: Dict, model: str) -> int:
    """
    è¨ˆç®—è¼¸å‡º tokens
    
    å„ªå…ˆä½¿ç”¨ API è¿”å›çš„ token è¨ˆæ•¸ï¼Œå¦å‰‡ä¼°ç®—
    """
    # å„ªå…ˆä½¿ç”¨ API è¿”å›çš„æº–ç¢º token è¨ˆæ•¸
    if "usage" in response and "completion_tokens" in response["usage"]:
        return response["usage"]["completion_tokens"]
    
    # API æ²’è¿”å›æ™‚é€²è¡Œä¼°ç®—
    generated_text = response.get("content", "")
    
    # æ ¹æ“šæ¨¡å‹ä¼°ç®—
    if model.startswith("gpt-"):
        return len(generated_text) // 4
    elif model.startswith("gemini-"):
        return len(generated_text) // 4
    else:
        return len(generated_text) // 4
```

### 4.2 æˆæœ¬è¨ˆç®—

#### ğŸ’° **å–®æ¬¡ API èª¿ç”¨æˆæœ¬**

```python
def calculate_single_cost(
    input_tokens: int,
    output_tokens: int,
    model: str,
    provider: str
) -> Dict[str, float]:
    """
    è¨ˆç®—å–®æ¬¡ API èª¿ç”¨çš„æˆæœ¬
    
    Args:
        input_tokens: è¼¸å…¥ tokens æ•¸é‡
        output_tokens: è¼¸å‡º tokens æ•¸é‡  
        model: ä½¿ç”¨çš„æ¨¡å‹
        provider: æ¨¡å‹æä¾›å•†
    
    Returns:
        æˆæœ¬æ˜ç´°å­—å…¸
    """
    # ç²å–æ¨¡å‹å®šåƒ¹
    pricing = get_model_pricing(model, provider)
    
    # è¨ˆç®—æˆæœ¬
    input_cost = (input_tokens / 1000) * pricing["input_price_per_1k"]
    output_cost = (output_tokens / 1000) * pricing["output_price_per_1k"]
    total_cost = input_cost + output_cost
    
    return {
        "input_cost": round(input_cost, 6),
        "output_cost": round(output_cost, 6),
        "total_cost": round(total_cost, 6),
        "pricing_used": pricing
    }

def get_model_pricing(model: str, provider: str) -> Dict[str, float]:
    """
    ç²å–æ¨¡å‹å®šåƒ¹
    
    å®šåƒ¹ç¤ºä¾‹ï¼ˆå¯¦éš›æ‡‰å¾é…ç½®æˆ–æ•¸æ“šåº«ç²å–ï¼‰
    """
    pricing_models = {
        "ollama": {
            "input_price_per_1k": 0.00015,
            "output_price_per_1k": 0.0006
        },
        "openai": {
            "input_price_per_1k": 0.0005,
            "output_price_per_1k": 0.0015
        },
        "google": {
            "input_price_per_1k": 0.000075,
            "output_price_per_1k": 0.0003
        },
        "qwen": {
            "input_price_per_1k": 0.0003,
            "output_price_per_1k": 0.0006
        },
        "chatglm": {
            "input_price_per_1k": 0.00025,
            "output_price_per_1k": 0.0005
        }
    }
    
    provider_pricing = pricing_models.get(provider.lower(), pricing_models["ollama"])
    
    # æ ¹æ“šæ¨¡å‹èª¿æ•´å®šåƒ¹ï¼ˆé«˜ç´šæ¨¡å‹æ›´è²´ï¼‰
    if "pro" in model.lower() or "turbo" in model.lower():
        provider_pricing = {
            k: v * 1.5 for k, v in provider_pricing.items()
        }
    
    return provider_pricing
```

### 4.3 èšåˆçµ±è¨ˆ

#### ğŸ“Š **æ¯æ—¥èšåˆ**

```python
async def aggregate_daily_usage(date: str) -> Dict[str, Any]:
    """
    èšåˆæ¯æ—¥ä½¿ç”¨çµ±è¨ˆ
    
    Args:
        date: æ—¥æœŸ (æ ¼å¼: YYYY-MM-DD)
    
    Returns:
        æ¯æ—¥çµ±è¨ˆæ‘˜è¦
    """
    start_timestamp = f"{date}T00:00:00.000Z"
    end_timestamp = f"{date}T23:59:59.999Z"
    
    # æŸ¥è©¢ç•¶æ—¥æ‰€æœ‰ API ä½¿ç”¨è¨˜éŒ„
    query = """
    FOR usage IN api_usage_logs
        FILTER usage.timestamp >= @start_timestamp AND usage.timestamp <= @end_timestamp
        COLLECT user_id, tenant_id, SUM(usage.usage_metrics.total_tokens) as total_tokens,
               COUNT(usage) as total_calls, AVG(usage.usage_metrics.response_time_ms) as avg_response_time
        GROUP BY user_id, tenant_id
    """
    
    # åŸ·è¡ŒèšåˆæŸ¥è©¢
    results = await execute_arango_query(query)
    
    # ç”Ÿæˆæ¯æ—¥æ‘˜è¦
    summaries = []
    for result in results:
        summary = {
            "_key": f"daily_summary_{date}_{result['user_id']}",
            "date": date,
            "user_id": result["user_id"],
            "tenant_id": result["tenant_id"],
            "total_calls": result["total_calls"],
            "total_tokens": result["total_tokens"],
            "avg_response_time_ms": result["avg_response_time"]
        }
        
        # æŒ‰æ¨¡å‹èšåˆä½¿ç”¨æƒ…æ³
        model_query = """
        FOR usage IN api_usage_logs
            FILTER usage.user_id == @user_id AND 
                   usage.timestamp >= @start_timestamp AND 
                   usage.timestamp <= @end_timestamp
            COLLECT usage.request_info.model as model,
                   SUM(usage.usage_metrics.total_tokens) as tokens_used,
                   COUNT(usage) as call_count
            GROUP BY model
        """
        
        model_results = await execute_arango_query(model_query, 
                                                  bind_vars={"user_id": result["user_id"]})
        
        summary["model_usage"] = {}
        for model_result in model_results:
            model_id = model_result["model"]
            # è¨ˆç®—è©²æ¨¡å‹çš„æˆæœ¬
            pricing = get_model_pricing(model_id, extract_provider(model_id))
            cost = (model_result["tokens_used"] / 1000) * \
                   (pricing["input_price_per_1k"] + pricing["output_price_per_1k"])
            
            summary["model_usage"][model_id] = {
                "call_count": model_result["call_count"],
                "tokens_used": model_result["tokens_used"],
                "cost": round(cost, 4)
            }
        
        summaries.append(summary)
    
    return summaries
```

---

## 5. æˆæœ¬è¨ˆç®—æ¨¡å‹

### 5.1 è¨ˆè²»æ¨¡å¼

#### ğŸ’³ **æŒ‰ä½¿ç”¨é‡è¨ˆè²»**

```python
def calculate_usage_based_billing(
    user_id: str,
    start_date: str,
    end_date: str
) -> Dict[str, Any]:
    """
    æŒ‰ä½¿ç”¨é‡è¨ˆç®—å¸³å–®
    
    è¨ˆç®—å…¬å¼ï¼š
    ç¸½æˆæœ¬ = Î£(è¼¸å…¥ tokens Ã— è¼¸å…¥å–®åƒ¹ + è¼¸å‡º tokens Ã— è¼¸å‡ºå–®åƒ¹)
    """
    # æŸ¥è©¢ä½¿ç”¨è¨˜éŒ„
    query = """
    FOR log IN api_usage_logs
        FILTER log.user_id == @user_id AND 
               log.timestamp >= @start_date AND 
               log.timestamp <= @end_date
        RETURN {
            date: DATE_TRUNC(log.timestamp, 'day'),
            total_tokens: SUM(log.usage_metrics.total_tokens),
            model_usage: COLLECT {
                model: item.request_info.model,
                input_tokens: SUM(item.usage_metrics.input_tokens),
                output_tokens: SUM(item.usage_metrics.output_tokens)
            }
        }
    """
    
    results = await execute_arango_query(query, 
                                       bind_vars={
                                           "user_id": user_id,
                                           "start_date": start_date,
                                           "end_date": end_date
                                       })
    
    # è¨ˆç®—æ¯æ—¥æˆæœ¬
    daily_costs = []
    total_cost = 0
    
    for day_result in results:
        day_date = day_result["date"]
        day_total_tokens = day_result["total_tokens"]
        
        # æŒ‰æ¨¡å‹è¨ˆç®—æˆæœ¬
        day_model_costs = {}
        day_cost = 0
        
        for model_usage in day_result["model_usage"]:
            model = model_usage["model"]
            input_tokens = model_usage["input_tokens"]
            output_tokens = model_usage["output_tokens"]
            
            # ç²å–æ¨¡å‹å®šåƒ¹
            pricing = get_model_pricing(model, extract_provider(model))
            
            # è¨ˆç®—æˆæœ¬
            model_cost = (input_tokens / 1000) * pricing["input_price_per_1k"] + \
                         (output_tokens / 1000) * pricing["output_price_per_1k"]
            
            day_model_costs[model] = round(model_cost, 4)
            day_cost += model_cost
        
        daily_costs.append({
            "date": day_date,
            "total_tokens": day_total_tokens,
            "total_cost": round(day_cost, 2),
            "model_breakdown": day_model_costs
        })
        
        total_cost += day_cost
    
    return {
        "user_id": user_id,
        "billing_period": {
            "start": start_date,
            "end": end_date
        },
        "daily_costs": daily_costs,
        "total_cost": round(total_cost, 2),
        "summary": {
            "total_days": len(daily_costs),
            "avg_daily_tokens": sum(day["total_tokens"] for day in daily_costs) // len(daily_costs),
            "avg_daily_cost": round(total_cost / len(daily_costs), 2)
        }
    }
```

#### ğŸ“¦ **é…é¡é™åˆ¶å®šåƒ¹**

```python
def calculate_quota_billing(
    user_id: str,
    month: str
) -> Dict[str, Any]:
    """
    åŸºæ–¼é…é¡çš„å®šåƒ¹
    
    ä¸åŒå±¤ç´šæœ‰ä¸åŒçš„å–®åƒ¹å’Œé…é¡
    """
    # ç²å–ç”¨æˆ¶å±¤ç´š
    user_tier = get_user_tier(user_id)
    
    # å±¤ç´šé…ç½®
    tier_configs = {
        "free": {
            "monthly_tokens": 100000,
            "price": 0.0
        },
        "basic": {
            "monthly_tokens": 1000000,
            "price": 10.0
        },
        "pro": {
            "monthly_tokens": 10000000,
            "price": 50.0
        },
        "enterprise": {
            "monthly_tokens": 100000000,
            "price": 200.0
        }
    }
    
    config = tier_configs[user_tier]
    used_tokens = get_monthly_usage(user_id, month)
    
    # è¶…å‡ºé…é¡çš„æŒ‰ä½¿ç”¨é‡è¨ˆè²»
    if used_tokens > config["monthly_tokens"]:
        excess_tokens = used_tokens - config["monthly_tokens"]
        # è¶…å‡ºéƒ¨åˆ†å–®åƒ¹æ›´é«˜
        excess_price = config["price"] / config["monthly_tokens"] * 2
        excess_cost = (excess_tokens / 1000) * excess_price
        total_cost = config["price"] + excess_cost
    else:
        total_cost = config["price"]
        excess_cost = 0
    
    return {
        "user_id": user_id,
        "month": month,
        "tier": user_tier,
        "quota": config["monthly_tokens"],
        "used_tokens": used_tokens,
        "excess_tokens": max(0, used_tokens - config["monthly_tokens"]),
        "base_cost": config["price"],
        "excess_cost": round(excess_cost, 2),
        "total_cost": round(total_cost, 2)
    }
```

### 5.2 æˆæœ¬å„ªåŒ–å»ºè­°

#### ğŸ¯ **æˆæœ¬å„ªåŒ–åˆ†æ**

```python
def analyze_cost_optimization(user_id: str) -> Dict[str, Any]:
    """
    åˆ†æç”¨æˆ¶çš„æˆæœ¬å„ªåŒ–æ©Ÿæœƒ
    
    åˆ†æç¶­åº¦ï¼š
    1. æ¨¡å‹ä½¿ç”¨æ¨¡å¼ï¼šæ˜¯å¦å¯åˆ‡æ›åˆ°æ›´ä¾¿å®œçš„æ¨¡å‹
    2. æ™‚é–“æ®µå„ªåŒ–ï¼šæ˜¯å¦å¯èª¿æ•´ä½¿ç”¨æ™‚é–“
    3. æ‰¹æ¬¡è™•ç†ï¼šæ˜¯å¦å¯åˆä½µè«‹æ±‚æ¸›å°‘ API èª¿ç”¨æ¬¡æ•¸
    """
    # ç²å–ç”¨æˆ¶ä½¿ç”¨æ•¸æ“š
    usage_data = await get_user_usage_analysis(user_id)
    
    # 1. æ¨¡å‹ä½¿ç”¨æ¨¡å¼åˆ†æ
    model_costs = {}
    for model, stats in usage_data["model_stats"].items():
        model_costs[model] = stats["total_cost"] / stats["total_calls"]
    
    # æ‰¾å‡ºæˆæœ¬æ•ˆç›Šæœ€é«˜çš„æ¨¡å‹
    best_model = min(model_costs.items(), key=lambda x: x[1])
    
    # 2. SmartQ-HCI ä½¿ç”¨å»ºè­°
    if usage_data["smartq_hci_usage"]["avg_response_time"] < 2000:
        smartq_recommendation = "ç¹¼çºŒä½¿ç”¨ SmartQ-HCIï¼Œæ€§èƒ½å„ªç•°"
    else:
        smartq_recommendation = "è€ƒæ…®ä½¿ç”¨å–®ä¸€é«˜æ€§èƒ½æ¨¡å‹ï¼Œå¯èƒ½æ›´å¿«é€Ÿ"
    
    # 3. æˆæœ¬å„ªåŒ–å»ºè­°
    recommendations = []
    
    if usage_data["avg_tokens_per_call"] < 500:
        recommendations.append({
            "type": "batch_processing",
            "title": "æ‰¹æ¬¡è™•ç†å„ªåŒ–",
            "description": "æ‚¨çš„å°è©±è¼ƒçŸ­ï¼Œå¯ä»¥è€ƒæ…®æ‰¹æ¬¡è™•ç†ä»¥æ¸›å°‘ API èª¿ç”¨æ¬¡æ•¸",
            "potential_savings": "15-20%"
        })
    
    if usage_data["peak_hours"] and len(usage_data["peak_hours"]) > 0:
        recommendations.append({
            "type": "time_shifting",
            "title": "æ™‚é–“æ®µå„ªåŒ–",
            "description": f"å°‡é«˜è² è·ä»»å‹™å®‰æ’åœ¨éé«˜å³°æœŸ {usage_data['off_peak_hours']}",
            "potential_savings": "25-30%"
        })
    
    return {
        "user_id": user_id,
        "analysis_period": "last_30_days",
        "model_cost_analysis": model_costs,
        "best_model": best_model[0],
        "smartq_recommendation": smartq_recommendation,
        "optimization_recommendations": recommendations,
        "potential_monthly_savings": "30-50%"
    }
```

---

## 6. ç›£æ§å’Œå ±å‘Š

### 6.1 å¯¦æ™‚ç›£æ§æŒ‡æ¨™

#### ğŸ“Š **æ ¸å¿ƒæŒ‡æ¨™**

| æŒ‡æ¨™é¡åˆ¥ | æŒ‡æ¨™åç¨± | è¨ˆç®—æ–¹å¼ | é–¾å€¼ |
|-----------|----------|----------|------|
| **ä½¿ç”¨é‡** | æ¯æ—¥ API èª¿ç”¨æ¬¡æ•¸ | COUNT() | - |
| **Token æ¶ˆè€—** | æ¯æ—¥ tokens ä½¿ç”¨é‡ | SUM() | - |
| **æˆæœ¬** | æ¯æ—¥æˆæœ¬ | SUM() | æœˆåº¦é ç®—çš„ 80% |
| **æ€§èƒ½** | å¹³å‡éŸ¿æ‡‰æ™‚é–“ | AVG() | 3000ms |
| **å¯ç”¨æ€§** | API æˆåŠŸç‡ | æˆåŠŸ/ç¸½æ•¸ | 99% |
| **ä¸¦ç™¼** | å³°å€¼ä¸¦ç™¼æ•¸ | MAX() | é…é¡çš„ 90% |

### 6.2 é è­¦æ©Ÿåˆ¶

#### âš ï¸ **é è­¦ç´šåˆ¥**

```python
class AlertLevel(Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"

class UsageAlert:
    """ä½¿ç”¨é‡é è­¦"""
    
    @staticmethod
    def check_and_alert(user_id: str):
        """
        æª¢æŸ¥ä¸¦ç™¼é€é è­¦
        """
        quota = get_user_quota(user_id)
        
        # æª¢æŸ¥å„é …æŒ‡æ¨™
        alerts = []
        
        # 1. æ¯æ—¥é…é¡é è­¦
        daily_tokens_pct = quota["current_usage"]["daily_tokens"] / quota["quota_limits"]["daily_tokens"]
        if daily_tokens_pct >= 0.9:
            alert = {
                "level": AlertLevel.CRITICAL,
                "type": "daily_quota",
                "message": f"å·²ä½¿ç”¨ {daily_tokens_pct*100:.0f}% çš„æ¯æ—¥ tokens é…é¡",
                "current": quota["current_usage"]["daily_tokens"],
                "limit": quota["quota_limits"]["daily_tokens"],
                "recommended_action": "æ¸›å°‘ä½¿ç”¨æˆ–ç­‰å¾…é…é¡é‡ç½®"
            }
            alerts.append(alert)
        
        # 2. æœˆåº¦æˆæœ¬é è­¦
        monthly_cost_pct = quota["current_usage"]["monthly_cost"] / quota["quota_limits"]["monthly_cost_limit"]
        if monthly_cost_pct >= 0.8:
            alert = {
                "level": AlertLevel.WARNING,
                "type": "monthly_cost",
                "message": f"å·²ä½¿ç”¨ {monthly_cost_pct*100:.0f}% çš„æœˆåº¦æˆæœ¬é ç®—",
                "current": quota["current_usage"]["monthly_cost"],
                "limit": quota["quota_limits"]["monthly_cost_limit"],
                "recommended_action": "è€ƒæ…®å‡ç´šå¥—é¤æˆ–å„ªåŒ–ä½¿ç”¨æ¨¡å¼"
            }
            alerts.append(alert)
        
        # 3. æ€§èƒ½é è­¦
        avg_response_time = get_average_response_time(user_id)
        if avg_response_time > 5000:
            alert = {
                "level": AlertLevel.INFO,
                "type": "performance",
                "message": f"å¹³å‡éŸ¿æ‡‰æ™‚é–“éé•·: {avg_response_time:.0f}ms",
                "current_avg": avg_response_time,
                "threshold": 5000,
                "recommended_action": "æª¢æŸ¥ç¶²çµ¡æˆ–è€ƒæ…®åˆ‡æ›æ¨¡å‹"
            }
            alerts.append(alert)
        
        # ç™¼é€é è­¦
        for alert in alerts:
            send_alert_notification(user_id, alert)
```

### 6.3 å ±å‘Šç”Ÿæˆ

#### ğŸ“ˆ **å ±å‘Šé¡å‹**

```python
class ReportGenerator:
    """å ±å‘Šç”Ÿæˆå™¨"""
    
    @staticmethod
    def generate_daily_report(user_id: str, date: str) -> Dict[str, Any]:
        """
        ç”Ÿæˆæ¯æ—¥å ±å‘Š
        
        å…§å®¹åŒ…æ‹¬ï¼š
        - ç•¶æ—¥ä½¿ç”¨æ‘˜è¦
        - æ¨¡å‹ä½¿ç”¨åˆ†å¸ƒ
        - æˆæœ¬æ˜ç´°
        - èˆ‡åŒæœŸæ¯”è¼ƒ
        """
        # ç²å–ç•¶æ—¥æ•¸æ“š
        daily_data = await get_daily_usage(user_id, date)
        previous_day_data = await get_daily_usage(user_id, 
                                                  get_previous_day(date))
        
        # ç”Ÿæˆå ±å‘Š
        report = {
            "report_type": "daily",
            "user_id": user_id,
            "date": date,
            "summary": {
                "total_calls": daily_data["total_calls"],
                "total_tokens": daily_data["total_tokens"],
                "total_cost": daily_data["total_cost"],
                "compared_to_previous": {
                    "calls_change": daily_data["total_calls"] - previous_day_data["total_calls"],
                    "tokens_change": daily_data["total_tokens"] - previous_day_data["total_tokens"],
                    "cost_change": daily_data["total_cost"] - previous_day_data["total_cost"]
                }
            },
            "model_breakdown": daily_data["model_usage"],
            "hourly_distribution": await get_hourly_distribution(user_id, date),
            "top_conversations": await get_top_conversations(user_id, date)
        }
        
        return report
    
    @staticmethod
    def generate_monthly_report(user_id: str, month: str) -> Dict[str, Any]:
        """
        ç”Ÿæˆæœˆåº¦å ±å‘Š
        
        å…§å®¹åŒ…æ‹¬ï¼š
        - æœˆåº¦ç¸½è¦½
        - è¶¨å‹¢åˆ†æ
        - æˆæœ¬åˆ†æ
        - ä½¿ç”¨æ¨¡å¼åˆ†æ
        """
        # ç²å–æœˆåº¦æ•¸æ“š
        monthly_data = await get_monthly_usage(user_id, month)
        previous_month_data = await get_monthly_usage(user_id, 
                                                      get_previous_month(month))
        
        # ç”Ÿæˆæœˆåº¦å ±å‘Š
        report = {
            "report_type": "monthly",
            "user_id": user_id,
            "month": month,
            "summary": {
                "total_calls": monthly_data["total_calls"],
                "total_tokens": monthly_data["total_tokens"],
                "total_cost": monthly_data["total_cost"],
                "avg_daily_tokens": monthly_data["total_tokens"] / monthly_data["total_days"],
                "peak_usage_day": monthly_data["peak_usage"]["date"]
            },
            "trend_analysis": {
                "month_over_month": {
                    "calls_change_pct": (monthly_data["total_calls"] - 
                                          previous_month_data["total_calls"]) / 
                                          previous_month_data["total_calls"] * 100,
                    "tokens_change_pct": (monthly_data["total_tokens"] - 
                                          previous_month_data["total_tokens"]) / 
                                          previous_month_data["total_tokens"] * 100,
                    "cost_change_pct": (monthly_data["total_cost"] - 
                                          previous_month_data["total_cost"]) / 
                                          previous_month_data["total_cost"] * 100
                }
            },
            "model_analysis": monthly_data["model_analysis"],
            "usage_patterns": monthly_data["usage_patterns"],
            "cost_optimization_suggestions": monthly_data["optimization_suggestions"]
        }
        
        return report
```

---

## 7. API è¨­è¨ˆ

### 7.1 æµé‡çµ±è¨ˆ API

#### ğŸ“Š **ç²å–ç”¨æˆ¶ä½¿ç”¨çµ±è¨ˆ**

```python
@router.get("/usage/stats/{user_id}", status_code=status.HTTP_200_OK)
async def get_user_usage_stats(
    user_id: str,
    period: str = "7d",  # 7d, 30d, 90d, 1y
    include_daily_breakdown: bool = True,
    tenant_id: str = Depends(get_current_tenant_id),
    current_user: User = Depends(get_current_user),
) -> JSONResponse:
    """
    ç²å–ç”¨æˆ¶ä½¿ç”¨çµ±è¨ˆ
    
    Args:
        user_id: ç”¨æˆ¶ ID
        period: çµ±è¨ˆé€±æœŸ
        include_daily_breakdown: æ˜¯å¦åŒ…å«æ¯æ—¥æ˜ç´°
        current_user: ç•¶å‰ç”¨æˆ¶ï¼ˆæ¬Šé™é©—è­‰ï¼‰
    
    Returns:
        ç”¨æˆ¶ä½¿ç”¨çµ±è¨ˆæ•¸æ“š
    """
    # æ¬Šé™æª¢æŸ¥ï¼šåªèƒ½æŸ¥çœ‹è‡ªå·±çš„çµ±è¨ˆæˆ–ç®¡ç†å“¡å¯æŸ¥çœ‹æ‰€æœ‰
    if current_user.user_id != user_id and not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="ç„¡æ¬ŠæŸ¥çœ‹å…¶ä»–ç”¨æˆ¶çš„ä½¿ç”¨çµ±è¨ˆ"
        )
    
    # è¨ˆç®—æ—¥æœŸç¯„åœ
    end_date = datetime.now()
    start_date = calculate_start_date(end_date, period)
    
    # æŸ¥è©¢çµ±è¨ˆæ•¸æ“š
    query = """
    FOR log IN api_usage_logs
        FILTER log.user_id == @user_id AND 
               log.timestamp >= @start_date AND 
               log.timestamp <= @end_date
        COLLECT {
            date: DATE_TRUNC(log.timestamp, 'day'),
            total_calls: COUNT(log),
            total_tokens: SUM(log.usage_metrics.total_tokens),
            total_cost: SUM(log.cost_info.total_cost),
            avg_response_time_ms: AVG(log.usage_metrics.response_time_ms),
            success_rate: COUNT(FILTER log.usage_metrics.status_code == 200) / COUNT(log)
        } GROUP BY date ORDER BY date ASC
    """
    
    results = await execute_arango_query(query, 
                                       bind_vars={
                                           "user_id": user_id,
                                           "start_date": start_date,
                                           "end_date": end_date
                                       })
    
    # å¦‚æœéœ€è¦æ¯æ—¥æ˜ç´°ï¼ŒæŸ¥è©¢æ¨¡å‹ä½¿ç”¨æƒ…æ³
    model_usage = []
    if include_daily_breakdown:
        model_query = """
        FOR log IN api_usage_logs
            FILTER log.user_id == @user_id AND 
                   log.timestamp >= @start_date AND 
                   log.timestamp <= @end_date
            COLLECT {
                model: log.request_info.model,
                calls: COUNT(log),
                tokens: SUM(log.usage_metrics.total_tokens),
                cost: SUM(log.cost_info.total_cost)
            } GROUP BY model ORDER BY tokens DESC
        """
        model_usage = await execute_arango_query(model_query, 
                                                       bind_vars={
                                                           "user_id": user_id,
                                                           "start_date": start_date,
                                                           "end_date": end_date
                                                       })
    
    # æ§‹å»ºå›æ‡‰
    total_calls = sum(day["total_calls"] for day in results)
    total_tokens = sum(day["total_tokens"] for day in results)
    total_cost = sum(day["total_cost"] for day in results)
    
    response = {
        "user_id": user_id,
        "period": period,
        "date_range": {
            "start": start_date.isoformat(),
            "end": end_date.isoformat()
        },
        "summary": {
            "total_calls": total_calls,
            "total_tokens": total_tokens,
            "total_cost": round(total_cost, 2),
            "avg_tokens_per_call": total_tokens / total_calls if total_calls > 0 else 0,
            "avg_response_time_ms": sum(day["avg_response_time_ms"] for day in results) / len(results),
            "overall_success_rate": sum(day["success_rate"] for day in results) / len(results)
        },
        "daily_breakdown": results,
        "model_usage": model_usage
    }
    
    return APIResponse.success(
        data=response,
        message="ä½¿ç”¨çµ±è¨ˆç²å–æˆåŠŸ"
    )
```

#### ğŸ’° **æˆæœ¬æŸ¥è©¢ API**

```python
@router.get("/usage/cost/{user_id}", status_code=status.HTTP_200_OK)
async def get_user_cost(
    user_id: str,
    period: str = "current_month",
    tenant_id: str = Depends(get_current_tenant_id),
    current_user: User = Depends(get_current_user),
) -> JSONResponse:
    """
    ç²å–ç”¨æˆ¶æˆæœ¬ä¿¡æ¯
    
    Args:
        user_id: ç”¨æˆ¶ ID
        period: æŸ¥è©¢é€±æœŸ (current_month, last_month, custom)
        custom_start: è‡ªå®šç¾©é–‹å§‹æ—¥æœŸ (å¯é¸)
        custom_end: è‡ªå®šç¾©çµæŸæ—¥æœŸ (å¯é¸)
        current_user: ç•¶å‰ç”¨æˆ¶
    
    Returns:
        æˆæœ¬æ˜ç´°å’Œçµ±è¨ˆ
    """
    # æ¬Šé™æª¢æŸ¥
    if current_user.user_id != user_id and not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="ç„¡æ¬ŠæŸ¥çœ‹å…¶ä»–ç”¨æˆ¶çš„æˆæœ¬ä¿¡æ¯"
        )
    
    # è¨ˆç®—æ—¥æœŸç¯„åœ
    if period == "current_month":
        end_date = datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        start_date = end_date.replace(month=end_date.month, day=1)
    elif period == "last_month":
        current_date = datetime.now()
        end_date = current_date.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        start_date = (end_date - timedelta(days=1)).replace(day=1)
    else:
        # è‡ªå®šç¾©æ—¥æœŸç¯„åœ
        start_date = parse_date(custom_start)
        end_date = parse_date(custom_end)
    
    # æŸ¥è©¢æˆæœ¬æ•¸æ“š
    query = """
    FOR log IN api_usage_logs
        FILTER log.user_id == @user_id AND 
               log.timestamp >= @start_date AND 
               log.timestamp <= @end_date
        COLLECT {
            date: DATE_TRUNC(log.timestamp, 'day'),
            total_cost: SUM(log.cost_info.total_cost),
            model_costs: COLLECT {
                model: log.request_info.model,
                cost: SUM(log.cost_info.total_cost)
            } GROUP BY model
        } GROUP BY date ORDER BY date ASC
    """
    
    results = await execute_arango_query(query, 
                                       bind_vars={
                                           "user_id": user_id,
                                           "start_date": start_date,
                                           "end_date": end_date
                                       })
    
    # èšåˆæ•¸æ“š
    total_cost = sum(day["total_cost"] for day in results)
    avg_daily_cost = total_cost / len(results) if results else 0
    
    # æ¨¡å‹æˆæœ¬èšåˆ
    model_cost_aggregation = {}
    for day in results:
        for model_cost in day["model_costs"]:
            model = model_cost["model"]
            cost = model_cost["cost"]
            if model not in model_cost_aggregation:
                model_cost_aggregation[model] = {"total_cost": 0, "days_used": 0}
            model_cost_aggregation[model]["total_cost"] += cost
            model_cost_aggregation[model]["days_used"] += 1
    
    # è¨ˆç®—æ¨¡å‹æˆæœ¬å æ¯”
    model_cost_percentage = {}
    for model, data in model_cost_aggregation.items():
        model_cost_percentage[model] = round(data["total_cost"] / total_cost * 100, 1)
    
    response = {
        "user_id": user_id,
        "period": period,
        "date_range": {
            "start": start_date.isoformat(),
            "end": end_date.isoformat()
        },
        "summary": {
            "total_cost": round(total_cost, 2),
            "avg_daily_cost": round(avg_daily_cost, 2),
            "total_days": len(results)
        },
        "model_cost_breakdown": [
            {
                "model": model,
                "total_cost": round(data["total_cost"], 2),
                "percentage": model_cost_percentage[model],
                "days_used": data["days_used"],
                "avg_daily_cost": round(data["total_cost"] / data["days_used"], 2)
            }
            for model, data in model_cost_aggregation.items()
        ]
    }
    
    return APIResponse.success(
        data=response,
        message="æˆæœ¬ä¿¡æ¯ç²å–æˆåŠŸ"
    )
```

#### ğŸ“ˆ **é…é¡æŸ¥è©¢ API**

```python
@router.get("/usage/quota/{user_id}", status_code=status.HTTP_200_OK)
async def get_user_quota(
    user_id: str,
    tenant_id: str = Depends(get_current_tenant_id),
    current_user: User = Depends(get_current_user),
) -> JSONResponse:
    """
    ç²å–ç”¨æˆ¶é…é¡ä¿¡æ¯
    
    Args:
        user_id: ç”¨æˆ¶ ID
        current_user: ç•¶å‰ç”¨æˆ¶
    
    Returns:
        é…é¡ä¿¡æ¯å’Œä½¿ç”¨æƒ…æ³
    """
    # æ¬Šé™æª¢æŸ¥
    if current_user.user_id != user_id and not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="ç„¡æ¬ŠæŸ¥çœ‹å…¶ä»–ç”¨æˆ¶çš„é…é¡ä¿¡æ¯"
        )
    
    # ç²å–é…é¡æ•¸æ“š
    quota = await get_user_quota_from_db(user_id)
    
    # è¨ˆç®—ç•¶å‰ä½¿ç”¨ç™¾åˆ†æ¯”
    usage_percentages = {
        "daily_tokens": round(
            quota["current_usage"]["daily_tokens"] / 
            quota["quota_limits"]["daily_tokens"] * 100, 1
        ),
        "daily_api_calls": round(
            quota["current_usage"]["daily_api_calls"] / 
            quota["quota_limits"]["daily_api_calls"] * 100, 1
        ),
        "monthly_cost": round(
            quota["current_usage"]["monthly_cost"] / 
            quota["quota_limits"]["monthly_cost_limit"] * 100, 1
        ),
        "concurrent_calls": round(
            quota["current_usage"]["current_concurrent"] / 
            quota["quota_limits"]["concurrent_calls"] * 100, 1
        )
    }
    
    # è¨ˆç®—å‰©ä½™è³‡æº
    remaining = {
        "daily_tokens": quota["quota_limits"]["daily_tokens"] - 
                        quota["current_usage"]["daily_tokens"],
        "daily_api_calls": quota["quota_limits"]["daily_api_calls"] - 
                          quota["current_usage"]["daily_api_calls"],
        "monthly_cost_remaining": quota["quota_limits"]["monthly_cost_limit"] - 
                                   quota["current_usage"]["monthly_cost"]
    }
    
    # è¨ˆç®—é‡ç½®æ™‚é–“
    now = datetime.now()
    next_day_reset = now.replace(day=now.day, hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)
    next_month_reset = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0) + 
                       timedelta(days=32 - now.day) if now.month == 12 else \
                       timedelta(days=32 - now.day) if now.month != 12 else timedelta(days=32 - now.day)
    
    response = {
        "user_id": user_id,
        "quota_limits": quota["quota_limits"],
        "current_usage": quota["current_usage"],
        "usage_percentages": usage_percentages,
        "remaining_resources": remaining,
        "reset_times": {
            "daily_reset": next_day_reset.isoformat(),
            "monthly_reset": next_month_reset.isoformat()
        },
        "status": "normal" if all(p < 100 for p in usage_percentages.values()) else "exceeded"
    }
    
    return APIResponse.success(
        data=response,
        message="é…é¡ä¿¡æ¯ç²å–æˆåŠŸ"
    )
```

### 7.2 ç®¡ç†å“¡ API

#### ğŸ‘¨ **ç³»çµ±ç´šåˆ¥çµ±è¨ˆ**

```python
@router.get("/usage/admin/system-stats", status_code=status.HTTP_200_OK)
async def get_system_usage_stats(
    start_date: str,
    end_date: str,
    granularity: str = "daily",  # hourly, daily, weekly, monthly
    tenant_id: str = Depends(get_current_tenant_id),
    current_user: User = Depends(get_current_user),
) -> JSONResponse:
    """
    ç²å–ç³»çµ±ç´šåˆ¥çš„ä½¿ç”¨çµ±è¨ˆï¼ˆç®¡ç†å“¡å°ˆç”¨ï¼‰
    
    Args:
        start_date: é–‹å§‹æ—¥æœŸ
        end_date: çµæŸæ—¥æœŸ
        granularity: çµ±è¨ˆç²’åº¦
        current_user: ç•¶å‰ç”¨æˆ¶ï¼ˆå¿…é ˆæ˜¯ç®¡ç†å“¡ï¼‰
    
    Returns:
        ç³»çµ±ä½¿ç”¨çµ±è¨ˆ
    """
    # ç®¡ç†å“¡æ¬Šé™æª¢æŸ¥
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="éœ€è¦ç®¡ç†å“¡æ¬Šé™"
        )
    
    # è§£ææ—¥æœŸ
    start_dt = parse_date(start_date)
    end_dt = parse_date(end_date)
    
    # æ§‹å»ºæŸ¥è©¢æ¢ä»¶
    if granularity == "hourly":
        date_format = "%Y-%m-%dT%H:00:00"
        date_trunc = "HOUR"
    elif granularity == "daily":
        date_format = "%Y-%m-%d"
        date_trunc = "DAY"
    elif granularity == "weekly":
        date_format = "%Y-W%W"
        date_trunc = "ISOWEEK"
    else:  # monthly
        date_format = "%Y-%m"
        date_trunc = "MONTH"
    
    # ç³»çµ±ç´šåˆ¥æŸ¥è©¢
    query = f"""
    FOR log IN api_usage_logs
        FILTER log.timestamp >= @start_dt AND log.timestamp <= @end_dt
        COLLECT {{
            period: DATE_FORMAT(log.timestamp, '{date_format}'),
            total_calls: COUNT(log),
            total_tokens: SUM(log.usage_metrics.total_tokens),
            total_cost: SUM(log.cost_info.total_cost),
            avg_response_time_ms: AVG(log.usage_metrics.response_time_ms),
            success_rate: COUNT(FILTER log.usage_metrics.status_code == 200) / COUNT(log),
            unique_users: COUNT(DISTINCT log.user_id),
            model_breakdown: COLLECT {{
                model: log.request_info.model,
                calls: COUNT(log),
                tokens: SUM(log.usage_metrics.total_tokens)
            }} GROUP BY model
        }} GROUP BY period ORDER BY period ASC
    """
    
    results = await execute_arango_query(query, 
                                       bind_vars={
                                           "start_dt": start_dt,
                                           "end_dt": end_dt
                                       })
    
    # èšåˆçµ±è¨ˆ
    total_calls = sum(period["total_calls"] for period in results)
    total_tokens = sum(period["total_tokens"] for period in results)
    total_cost = sum(period["total_cost"] for period in results)
    total_unique_users = max(period["unique_users"] for period in results)
    
    # è¶¨å‹¢åˆ†æ
    if len(results) > 1:
        first_period = results[0]
        last_period = results[-1]
        growth_rate = {
            "calls": round((last_period["total_calls"] - first_period["total_calls"]) / 
                         first_period["total_calls"] * 100, 1) if first_period["total_calls"] > 0 else 0,
            "tokens": round((last_period["total_tokens"] - first_period["total_tokens"]) / 
                           first_period["total_tokens"] * 100, 1) if first_period["total_tokens"] > 0 else 0,
            "cost": round((last_period["total_cost"] - first_period["total_cost"]) / 
                        first_period["total_cost"] * 100, 1) if first_period["total_cost"] > 0 else 0
        }
    else:
        growth_rate = {"calls": 0, "tokens": 0, "cost": 0}
    
    response = {
        "period": {
            "start": start_date,
            "end": end_date,
            "granularity": granularity
        },
        "summary": {
            "total_calls": total_calls,
            "total_tokens": total_tokens,
            "total_cost": round(total_cost, 2),
            "total_unique_users": total_unique_users,
            "avg_response_time_ms": sum(period["avg_response_time_ms"] for period in results) / len(results),
            "overall_success_rate": sum(period["success_rate"] for period in results) / len(results)
        },
        "trend_analysis": growth_rate,
        "period_breakdown": results
    }
    
    return APIResponse.success(
        data=response,
        message="ç³»çµ±çµ±è¨ˆç²å–æˆåŠŸ"
    )
```

---

## 8. å‰ç«¯é›†æˆ

### 8.1 TypeScript API å®¢æˆ¶ç«¯

#### ğŸ“Š **æµé‡çµ±è¨ˆ API å®¢æˆ¶ç«¯**

```typescript
/**
 * æµé‡çµ±è¨ˆç›¸é—œ API
 */

/**
 * ç²å–ç”¨æˆ¶ä½¿ç”¨çµ±è¨ˆ
 */
export async function getUserUsageStats(
  userId: string,
  period: string = "7d",
  includeDailyBreakdown: boolean = true
): Promise<{
  success: boolean;
  data?: {
    user_id: string;
    period: string;
    date_range: {
      start: string;
      end: string;
    };
    summary: {
      total_calls: number;
      total_tokens: number;
      total_cost: number;
      avg_tokens_per_call: number;
      avg_response_time_ms: number;
      overall_success_rate: number;
    };
    daily_breakdown?: Array<{
      date: string;
      total_calls: number;
      total_tokens: number;
      total_cost: number;
      avg_response_time_ms: number;
      success_rate: number;
    }>;
    model_usage?: Array<{
      model: string;
      calls: number;
      tokens: number;
      cost: number;
    }>;
  };
  message?: string;
}> {
  const params = new URLSearchParams();
  params.append('period', period);
  if (includeDailyBreakdown) {
    params.append('include_daily_breakdown', 'true');
  }
  
  return apiGet<{
    success: boolean;
    data?: any;
    message?: string;
  }>(`/usage/stats/${userId}?${params.toString()}`);
}

/**
 * ç²å–ç”¨æˆ¶æˆæœ¬ä¿¡æ¯
 */
export async function getUserCost(
  userId: string,
  period: string = "current_month",
  customStart?: string,
  customEnd?: string
): Promise<{
  success: boolean;
  data?: {
    user_id: string;
    period: string;
    date_range: {
      start: string;
      end: string;
    };
    summary: {
      total_cost: number;
      avg_daily_cost: number;
      total_days: number;
    };
    model_cost_breakdown: Array<{
      model: string;
      total_cost: number;
      percentage: number;
      days_used: number;
      avg_daily_cost: number;
    }>;
  };
  message?: string;
}> {
  const params = new URLSearchParams();
  params.append('period', period);
  if (customStart) params.append('custom_start', customStart);
  if (customEnd) params.append('custom_end', customEnd);
  
  return apiGet<{
    success: boolean;
    data?: any;
    message?: string;
  }>(`/usage/cost/${userId}?${params.toString()}`);
}

/**
 * ç²å–ç”¨æˆ¶é…é¡ä¿¡æ¯
 */
export async function getUserQuota(
  userId: string
): Promise<{
  success: boolean;
  data?: {
    user_id: string;
    quota_limits: {
      daily_tokens: number;
      daily_api_calls: number;
      monthly_cost_limit: number;
      concurrent_calls: number;
    };
    current_usage: {
      daily_tokens_used: number;
      daily_api_calls_used: number;
      monthly_cost: number;
      current_concurrent: number;
    };
    usage_percentages: {
      daily_tokens: number;
      daily_api_calls: number;
      monthly_cost: number;
      concurrent_calls: number;
    };
    remaining_resources: {
      daily_tokens: number;
      daily_api_calls: number;
      monthly_cost_remaining: number;
    };
    reset_times: {
      daily_reset: string;
      monthly_reset: string;
    };
    status: "normal" | "exceeded";
  };
  message?: string;
}> {
  return apiGet<{
    success: boolean;
    data?: any;
    message?: string;
  }>(`/usage/quota/${userId}`);
}
```

#### ğŸ“ˆ **æµé‡ç›£æ§çµ„ä»¶**

```typescript
/**
 * æµé‡ç›£æ§å„€è¡¨æ¿çµ„ä»¶
 */
import React, { useState, useEffect } from 'react';
import {
  getUserUsageStats,
  getUserCost,
  getUserQuota
} from '@/lib/api';

interface UsageDashboardProps {
  userId: string;
}

export const UsageDashboard: React.FC<UsageDashboardProps> = ({ userId }) => {
  const [usageStats, setUsageStats] = useState<any>(null);
  const [costInfo, setCostInfo] = useState<any>(null);
  const [quotaInfo, setQuotaInfo] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const loadUsageData = async () => {
      try {
        setLoading(true);
        
        // ä¸¦ç™¼åŠ è¼‰æ•¸æ“š
        const [statsResp, costResp, quotaResp] = await Promise.all([
          getUserUsageStats(userId),
          getUserCost(userId),
          getUserQuota(userId)
        ]);
        
        if (statsResp.success && statsResp.data) {
          setUsageStats(statsResp.data);
        }
        
        if (costResp.success && costResp.data) {
          setCostInfo(costResp.data);
        }
        
        if (quotaResp.success && quotaResp.data) {
          setQuotaInfo(quotaResp.data);
        }
        
      } catch (error) {
        console.error('[UsageDashboard] Failed to load usage data:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadUsageData();
  }, [userId]);
  
  if (loading) {
    return <div>åŠ è¼‰ä¸­...</div>;
  }
  
  return (
    <div className="space-y-6">
      {/* é…é¡å¡ç‰‡ */}
      {quotaInfo && (
        <div className="bg-white rounded-lg shadow p-6">
          <h3 className="text-lg font-semibold mb-4">é…é¡ä½¿ç”¨æƒ…æ³</h3>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <div className="text-sm text-gray-500">æ¯æ—¥ Tokens</div>
              <div className="text-2xl font-bold">
                {quotaInfo.current_usage.daily_tokens_used.toLocaleString()} / 
                {quotaInfo.quota_limits.daily_tokens.toLocaleString()}
              </div>
              <div className="text-sm" style={{ color: getUsageColor(quotaInfo.usage_percentages.daily_tokens) }}>
                {quotaInfo.usage_percentages.daily_tokens.toFixed(1)}%
              </div>
            </div>
            <div>
              <div className="text-sm text-gray-500">æœˆåº¦æˆæœ¬</div>
              <div className="text-2xl font-bold">
                ${quotaInfo.current_usage.monthly_cost.toFixed(2)} / 
                ${quotaInfo.quota_limits.monthly_cost_limit.toFixed(2)}
              </div>
              <div className="text-sm" style={{ color: getUsageColor(quotaInfo.usage_percentages.monthly_cost) }}>
                {quotaInfo.usage_percentages.monthly_cost.toFixed(1)}%
              </div>
            </div>
          </div>
        </div>
      )}
      
      {/* ä½¿ç”¨çµ±è¨ˆå¡ç‰‡ */}
      {usageStats && (
        <div className="bg-white rounded-lg shadow p-6">
          <h3 className="text-lg font-semibold mb-4">ä½¿ç”¨çµ±è¨ˆ</h3>
          <div className="grid grid-cols-4 gap-4">
            <div>
              <div className="text-sm text-gray-500">ç¸½èª¿ç”¨æ¬¡æ•¸</div>
              <div className="text-2xl font-bold">
                {usageStats.summary.total_calls.toLocaleString()}
              </div>
            </div>
            <div>
              <div className="text-sm text-gray-500">ç¸½ Tokens</div>
              <div className="text-2xl font-bold">
                {usageStats.summary.total_tokens.toLocaleString()}
              </div>
            </div>
            <div>
              <div className="text-sm text-gray-500">ç¸½æˆæœ¬</div>
              <div className="text-2xl font-bold">
                ${usageStats.summary.total_cost.toFixed(2)}
              </div>
            </div>
            <div>
              <div className="text-sm text-gray-500">å¹³å‡éŸ¿æ‡‰æ™‚é–“</div>
              <div className="text-2xl font-bold">
                {usageStats.summary.avg_response_time_ms.toFixed(0)}ms
              </div>
            </div>
          </div>
        </div>
      )}
      
      {/* æˆæœ¬åˆ†æå¡ç‰‡ */}
      {costInfo && (
        <div className="bg-white rounded-lg shadow p-6">
          <h3 className="text-lg font-semibold mb-4">æˆæœ¬åˆ†æ</h3>
          <div className="space-y-4">
            {costInfo.model_cost_breakdown.map((model: any) => (
              <div key={model.model} className="flex items-center justify-between">
                <div>
                  <div className="font-medium">{model.model}</div>
                  <div className="text-sm text-gray-500">
                    {model.days_used} å¤©ä½¿ç”¨
                  </div>
                </div>
                <div className="text-right">
                  <div className="text-xl font-bold">
                    ${model.total_cost.toFixed(2)}
                  </div>
                  <div className="text-sm text-gray-500">
                    ({model.percentage}%)
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

// è¼”åŠ©å‡½æ•¸
function getUsageColor(percentage: number): string {
  if (percentage >= 90) return '#ef4444'; // ç´…è‰²
  if (percentage >= 70) return '#f59e0b'; // æ©™è‰²
  return '#10b981'; // ç¶ è‰²
}
```

---

## 9. å¯¦ç¾è¨ˆåŠƒ

### 9.1 é–‹ç™¼éšæ®µ

#### Phase 1: æ•¸æ“šæ¨¡å‹å’Œå­˜å„² (1-2 é€±)

- [ ] å‰µå»º ArangoDB é›†åˆ
- [ ] å¯¦ç¾æ•¸æ“šæ¨¡å‹é¡
- [ ] è¨­è¨ˆæ•¸æ“šåº«ç´¢å¼•
- [ ] ç·¨å¯«æ•¸æ“šåº«é·ç§»è…³æœ¬
- [ ] æ¸¬è©¦æ•¸æ“šåº«æ€§èƒ½

#### Phase 2: æµé‡æ”¶é›†æœå‹™ (2-3 é€±)

- [ ] å¯¦ç¾ API èª¿ç”¨ä¸­é–“ä»¶
- [ ] å‰µå»ºæµé‡æ”¶é›†æœå‹™
- [ ] å¯¦ç¾ Token è¨ˆç®—é‚è¼¯
- [ ] å¯¦ç¾æˆæœ¬è¨ˆç®—é‚è¼¯
- [ ] å–®å…ƒæ¸¬è©¦æ”¶é›†æµç¨‹

#### Phase 3: API é–‹ç™¼ (1-2 é€±)

- [ ] å¯¦ç¾ç”¨æˆ¶çµ±è¨ˆ API
- [ ] å¯¦ç¾æˆæœ¬æŸ¥è©¢ API
- [ ] å¯¦ç¾é…é¡æŸ¥è©¢ API
- [ ] å¯¦ç¾ç®¡ç†å“¡çµ±è¨ˆ API
- [ ] API æ–‡æª”ç·¨å¯«

#### Phase 4: å‰ç«¯é–‹ç™¼ (2-3 é€±)

- [ ] å¯¦ç¾æµé‡çµ±è¨ˆ API å®¢æˆ¶ç«¯
- [ ] é–‹ç™¼ä½¿ç”¨å„€è¡¨æ¿çµ„ä»¶
- [ ] å¯¦ç¾æˆæœ¬åˆ†æé é¢
- [ ] å¯¦ç¾é…é¡ç›£æ§é é¢
- [ ] å¯¦ç¾é è­¦é€šçŸ¥çµ„ä»¶

#### Phase 5: èšåˆå’Œåˆ†ææœå‹™ (2-3 é€±)

- [ ] å¯¦ç¾æ¯æ—¥èšåˆä»»å‹™
- [ ] å¯¦ç¾çµ±è¨ˆåˆ†ææœå‹™
- [ ] å¯¦ç¾å ±å‘Šç”Ÿæˆæœå‹™
- [ ] å¯¦ç¾é è­¦æœå‹™
- [ ] æ€§èƒ½å„ªåŒ–

#### Phase 6: æ¸¬è©¦å’Œå„ªåŒ– (1-2 é€±)

- [ ] ç«¯åˆ°ç«¯æ¸¬è©¦
- [ ] æ€§èƒ½æ¸¬è©¦å’Œå„ªåŒ–
- [ ] å£“åŠ›æ¸¬è©¦
- [ ] å®‰å…¨æ¸¬è©¦
- [ ] æ–‡æª”å®Œå–„

### 9.2 éƒ¨ç½²è¨ˆåŠƒ

#### ğŸš€ **ç”Ÿç”¢éƒ¨ç½²**

**éƒ¨ç½²é †åº**ï¼š
1. æ•¸æ“šåº«å‡ç´šå’Œé·ç§»
2. API æœå‹™éƒ¨ç½²
3. æµé‡æ”¶é›†æœå‹™å•Ÿå‹•
4. å‰ç«¯éƒ¨ç½²
5. ç›£æ§å’Œå‘Šè­¦å•Ÿå‹•

**å›æ»¾è¨ˆåŠƒ**ï¼š
- ä¿ç•™åŸæœ‰çµ±è¨ˆé‚è¼¯
- é€šéé…ç½®é–‹é—œæ§åˆ¶æ–°åŠŸèƒ½
- ç›£æ§é—œéµæŒ‡æ¨™å’ŒéŒ¯èª¤æ—¥èªŒ

### 9.3 ç¶­è­·è¨ˆåŠƒ

**æ—¥å¸¸ç¶­è­·**ï¼š
- ç›£æ§æ•¸æ“šæ”¶é›†è³ªé‡
- æª¢æŸ¥ API æ€§èƒ½æŒ‡æ¨™
- ç¶­è­·æ•¸æ“šåº«ç´¢å¼•
- è™•ç†ç”¨æˆ¶åé¥‹

**å®šæœŸå„ªåŒ–**ï¼š
- æ¯æœˆé€²è¡Œæ€§èƒ½å„ªåŒ–
- æ¯å­£åº¦é€²è¡ŒåŠŸèƒ½æ“´å±•
- æ ¹æ“šä½¿ç”¨æ•¸æ“šå„ªåŒ–å®šåƒ¹ç­–ç•¥
- æ›´æ–°æ–‡æª”å’Œç”¨æˆ¶æŒ‡å—

---

## 10. é¢¨éšªè©•ä¼°

### 10.1 æ½›åœ¨é¢¨éšª

| é¢¨éšª | å½±éŸ¿ | æ¦‚ç‡ | ç·©è§£æªæ–½ |
|------|------|------|----------|
| æ•¸æ“šæ€§èƒ½å•é¡Œ | é«˜ | ä¸­ | å„ªåŒ–æ•¸æ“šåº«æŸ¥è©¢ã€ä½¿ç”¨ç´¢å¼•ã€å¯¦æ–½åˆ†é  |
| æˆæœ¬è¨ˆç®—æº–ç¢ºæ€§ | é«˜ | ä¸­ | å®šæœŸèˆ‡å¯¦éš›å¸³å–®å°æ¯”ã€æä¾›æˆæœ¬èª¿æ•´æ©Ÿåˆ¶ |
| ç”¨æˆ¶éš±ç§å•é¡Œ | ä¸­ | ä½ | éµå®ˆéš±ç§æ³•è¦ã€å¯¦ç¾æ•¸æ“šåŒ¿ååŒ– |
| ç³»çµ±è¤‡é›œåº¦ | ä¸­ | ä¸­ | æ¨¡å¡ŠåŒ–è¨­è¨ˆã€å®Œå–„æ–‡æª”ã€é€æ­¥å¯¦ç¾ |
| æ•¸æ“šä¸€è‡´æ€§ | é«˜ | ä½ | å¯¦æ–½æ•¸æ“šæ ¡é©—ã€å®šæœŸå‚™ä»½ã€äº‹å‹™æ©Ÿåˆ¶ |

### 10.2 æ€§èƒ½ç›®æ¨™

| æŒ‡æ¨™ | ç›®æ¨™ | ç›£æ§æ–¹å¼ |
|------|------|----------|
| API éŸ¿æ‡‰æ™‚é–“ | < 100ms (ä¸­é–“ä»¶) | APM ç›£æ§ |
| æ•¸æ“šå¯«å…¥å»¶é² | < 50ms | æ•¸æ“šåº«ç›£æ§ |
| çµ±è¨ˆæŸ¥è©¢æ€§èƒ½ | < 500ms (95th percentile) | æŸ¥è©¢å„ªåŒ– |
| ä¸¦ç™¼è™•ç†èƒ½åŠ› | 1000+ RPS | è² è¼‰æ¸¬è©¦ |
| å­˜å„²ç©ºé–“ä½¿ç”¨ | < 80% | å®šæœŸæ¸…ç† |

### 10.3 æ“´å±•æ€§è¨­è¨ˆ

**æ°´å¹³æ“´å±•**ï¼š
- æ”¯æŒæ•¸æ“šåº«åˆ†ç‰‡
- æ”¯æŒå¤šå¯¦ä¾‹éƒ¨ç½²
- æ”¯æŒåˆ†å¸ƒå¼æµé‡æ”¶é›†

**å‚ç›´æ“´å±•**ï¼š
- æ”¯æŒæ–°çš„æ•¸æ“šæºæ¥å…¥
- æ”¯æŒæ–°çš„çµ±è¨ˆç¶­åº¦
- æ”¯æŒæ–°çš„å ±å‘Šé¡å‹
- æ”¯æŒæ–°çš„è¨ˆè²»æ¨¡å¼

---

**æ–‡æª”ç¶­è­·**: AI-Box é–‹ç™¼åœ˜éšŠ  
**æŠ€è¡“æ”¯æŒ**: support@ai-box.com  
**æ›´æ–°é »ç‡**: å­£åº¦æ›´æ–°æˆ–é‡å¤§è®Šæ›´æ™‚æ›´æ–°
