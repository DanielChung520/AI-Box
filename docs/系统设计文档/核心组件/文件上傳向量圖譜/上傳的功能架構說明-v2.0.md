# 文件上傳功能架構說明 v2.0

## 文檔信息

- **版本**: 2.0
- **創建日期**: 2025-01-27
- **創建人**: Daniel Chung
- **最後修改日期**: 2025-12-29

**更新記錄**：

- 2025-12-29：添加文件存儲後端說明和 S3 URI 返回格式說明

---

## 目錄

1. [概述](#概述)
2. [完整流程追蹤](#完整流程追蹤)
3. [Ontology 系統詳解](#ontology-系統詳解)
4. [文件上傳後顯示問題分析](#文件上傳後顯示問題分析)
5. [相關服務和依賴](#相關服務和依賴)
6. [API 端點總結](#api-端點總結)
7. [數據流](#數據流)
8. [已知問題與改進計劃](#已知問題與改進計劃)

---

## 概述

本文檔詳細說明 AI-Box 系統中文件上傳功能的完整架構，包括前端觸發、API 調用、後端處理、異步任務執行，以及 Ontology 在知識圖譜提取中的應用。

### 主要功能

- 多文件上傳（支持拖拽和點擊選擇）
- 文件類型驗證（PDF, Word, Excel, Markdown, CSV, TXT, 圖片等）
- 自動任務創建（首次上傳時）
- 異步處理流程（分塊、向量化、知識圖譜提取）
- Ontology 自動選擇和應用
- 實時進度追蹤

---

## 完整流程追蹤

### 1. 前端觸發階段

#### 1.1 組件位置

- **文件**: `ai-bot/src/components/ChatInput.tsx`
- **上傳按鈕**: 第 1433-1439 行

#### 1.2 點擊處理

```typescript
// 第 754-756 行
const handlePaperclipClick = () => {
  setShowFileUploadModal(true);
};
```

#### 1.3 文件上傳模態框

- **組件**: `FileUploadModal`
- **文件**: `ai-bot/src/components/FileUploadModal.tsx`
- **功能**:
  - 文件選擇和驗證
  - 拖拽上傳支持
  - 圖片預覽
  - 任務工作區選擇

#### 1.4 文件上傳處理

- **函數**: `handleFileUpload`
- **位置**: `ChatInput.tsx` 第 758-1012 行
- **關鍵邏輯**:
  - 任務創建檢查（新任務自動創建）
  - 調用 `uploadFiles` API
  - 進度更新
  - 結果處理和事件觸發

---

### 2. API 調用階段

#### 2.1 API 函數

- **文件**: `ai-bot/src/lib/api.ts`
- **函數**: `uploadFiles`
- **位置**: 第 509-651 行

#### 2.2 API 端點

- **URL**: `POST /api/v1/files/upload`
- **Content-Type**: `multipart/form-data`
- **參數**:
  - `files`: File[] (多個文件)
  - `task_id`: string (可選，任務ID)
  - `target_folder_id`: string (可選，目標資料夾ID)

#### 2.3 請求實現

使用 `XMLHttpRequest` 以支持進度追蹤：

```typescript
const xhr = new XMLHttpRequest();
xhr.upload.addEventListener('progress', (e) => {
  if (e.lengthComputable && onProgress) {
    const percentComplete = Math.round((e.loaded / e.total) * 100);
    onProgress(percentComplete);
  }
});
```

#### 2.4 響應格式

```typescript
interface FileUploadResponse {
  success: boolean;
  data?: {
    uploaded: Array<{
      file_id: string;
      filename: string;
      file_type: string;
      file_size: number;
      file_path: string;
    }>;
    errors: Array<{
      filename: string;
      error: string;
    }>;
    total: number;
    success_count: number;
    error_count: number;
  };
}
```

---

### 3. 後端處理階段

#### 3.1 路由定義

- **文件**: `api/routers/file_upload.py`
- **路由**: `@router.post("/upload")`
- **位置**: 第 1624-2064 行

#### 3.2 處理流程

##### 3.2.1 權限檢查

- **服務**: `FilePermissionService`
- **方法**: `check_upload_permission(current_user)`
- **位置**: 第 1679-1680 行

##### 3.2.2 任務處理邏輯

- **服務**: `UserTaskService`
- **邏輯**:
  1. 如果提供了 `task_id`，檢查任務是否存在
  2. 如果任務不存在，自動創建新任務（使用第一個文件名作為任務標題）
  3. 如果未提供 `task_id`，創建新任務並生成新的 `task_id`
- **位置**: 第 1685-1807 行

##### 3.2.3 文件驗證

- **服務**: `FileValidator`
- **方法**: `validate_upload_file(file_content, filename)`
- **驗證內容**:
  - 文件類型（MIME 類型和擴展名）
  - 文件大小（默認最大 50MB）
- **位置**: 第 1809 行、第 1849-1860 行

##### 3.2.4 文件存儲

- **服務**: `FileStorage`
- **方法**: `save_file(file_content, filename, task_id)`
- **存儲位置**: 任務工作區目錄（`data/tasks/{task_id}/workspace/`）
- **位置**: 第 1810 行、第 1881-1883 行

##### 3.2.5 元數據創建

- **服務**: `FileMetadataService`
- **方法**: `create(FileMetadataCreate(...))`
- **存儲位置**: ArangoDB `file_metadata` collection
- **位置**: 第 1892-1910 行

##### 3.2.6 異步處理任務提交

- **隊列**: `FILE_PROCESSING_QUEUE`
- **任務**: `process_file_chunking_and_vectorization_task`
- **位置**: 第 1986-2009 行

```python
queue = get_task_queue(FILE_PROCESSING_QUEUE)
job = queue.enqueue(
    process_file_chunking_and_vectorization_task,
    file_id=file_id,
    file_path=file_path,
    file_type=file_type,
    user_id=current_user.user_id,
)
```

---

### 4. 異步處理階段

#### 4.1 處理任務定義

- **文件**: `workers/tasks.py`
- **任務名**: `process_file_chunking_and_vectorization_task`

#### 4.2 處理流程函數

- **文件**: `api/routers/file_upload.py`
- **函數名**: `process_file_chunking_and_vectorization`
- **位置**: 第 401-839 行

#### 4.3 處理階段詳解

##### 階段 1: 文件解析和分塊 (0-50%)

- **進度**: 0-50%
- **功能**:
  - 解析文件內容（根據文件類型選擇對應的解析器）
  - 分塊處理（文本文件）或生成描述（圖片文件）
- **服務**:
  - `ParserFactory` - 根據文件類型獲取解析器
  - `ChunkProcessor` - 文本分塊處理
- **位置**: 第 432-560 行

**圖片文件特殊處理**:

- 使用視覺模型（Vision Model）生成圖片描述
- 描述文本作為單個 chunk，不需要分塊
- 跳過知識圖譜提取階段

##### 階段 2: 向量化 (50-90%)

- **進度**: 50-90%
- **服務**: `EmbeddingService`
- **方法**: `generate_embeddings_batch(chunk_texts, progress_callback)`
- **位置**: 第 568-618 行

##### 階段 3: 存儲到 ChromaDB (90-100%)

- **進度**: 90-100%
- **服務**: `VectorStoreService`
- **方法**: `store_vectors(file_id, chunks, embeddings, user_id)`
- **位置**: 第 620-675 行

##### 階段 4: 知識圖譜提取 (90-100%)

- **進度**: 90-100%
- **服務**: `KGExtractionService`
- **方法**: `extract_and_build_incremental(...)`
- **位置**: 第 677-797 行
- **注意**: 圖片文件跳過此階段

**Ontology 應用**:

- 自動選擇合適的 Ontology（基於文件名、內容、元數據）
- 合併 Base、Domain、Major 三層 Ontology
- 生成 Prompt 模板（用於 LLM 調用）
- 詳細說明見 [Ontology 系統詳解](#ontology-系統詳解)

#### 4.4 狀態更新

- **存儲位置**: Redis + ArangoDB（雙寫模式）
- **函數**: `_update_processing_status`
- **位置**: 第 272-398 行
- **更新內容**:
  - 總體狀態和進度
  - 各階段狀態（chunking, vectorization, storage, kg_extraction）
  - 錯誤信息（如有）

---

### 5. 前端響應處理

#### 5.1 上傳成功處理

- **位置**: `ChatInput.tsx` 第 870-923 行
- **功能**:
  - 更新文件狀態為 `success`
  - 觸發 `fileUploaded` 事件
  - 觸發 `filesUploaded` 事件（通知文件樹更新）

```typescript
// 觸發文件上傳完成事件
window.dispatchEvent(new CustomEvent('fileUploaded', {
  detail: { fileIds: response.data.uploaded?.map((u: any) => u.file_id) || [] }
}));

// 觸發文件樹更新事件
window.dispatchEvent(new CustomEvent('filesUploaded', {
  detail: {
    taskId: finalTaskId,
    files: response.data.uploaded.map((u: any) => ({
      file_id: u.file_id,
      filename: u.filename,
      file_type: u.file_type,
      file_size: u.file_size,
    }))
  }
}));
```

#### 5.2 錯誤處理

- **位置**: `ChatInput.tsx` 第 934-1011 行
- **功能**:
  - 處理網絡錯誤
  - 嘗試使用模擬文件上傳（fallback）
  - 如果上傳失敗且是新任務，清除任務

---

## Ontology 系統詳解

### 1. Ontology 概述

Ontology（本體）是知識圖譜的結構化定義，用於約束實體類型和關係類型。AI-Box 系統使用三層 Ontology 架構：

- **Base Layer（基礎層）**: 通用實體和關係定義（如 Person, Organization, TimePoint 等）
- **Domain Layer（領域層）**: 特定領域的實體和關係（如 Enterprise, Administration 等）
- **Major Layer（專業層）**: 特定專業的實體和關係（如 Manufacture, NotionEditor 等）

### 2. Ontology 存儲架構

#### 2.1 存儲位置

**ArangoDB Collection**: `ontologies`

**數據結構**:

```python
{
  "_key": "{type}-{name}-{version}" 或 "{type}-{name}-{version}-{tenant_id}",
  "tenant_id": Optional[str],  # null 表示全局共享
  "type": "base" | "domain" | "major",
  "name": str,  # Ontology 名稱
  "version": str,  # 語義化版本（如 "1.0.0"）
  "default_version": bool,
  "ontology_name": str,
  "entity_classes": List[EntityClass],
  "object_properties": List[ObjectProperty],
  "is_active": bool,
  "created_at": str,
  "updated_at": str,
  # ... 其他元數據
}
```

#### 2.2 存儲服務

**服務**: `OntologyStoreService`

- **文件**: `services/api/services/ontology_store_service.py`
- **功能**:
  - Ontology CRUD 操作
  - 多租戶支持（租戶專屬 Ontology）
  - 版本管理
  - Ontology 合併

#### 2.3 查詢優先級

**方法**: `get_ontology_with_priority`

- **優先級**: 租戶專屬 > 全局共享
- **位置**: `ontology_store_service.py` 第 221-283 行

```python
# 1. 先查詢租戶專屬的默認版本
if tenant_id:
    filters = {
        "tenant_id": tenant_id,
        "type": type,
        "name": name,
        "default_version": True,
        "is_active": True,
    }
    results = self._collection.find(filters, limit=1, sort=["-created_at"])
    if results:
        return _document_to_model(results[0])

# 2. 再查詢全局共享的默認版本
filters = {
    "tenant_id": None,
    "type": type,
    "name": name,
    "default_version": True,
    "is_active": True,
}
results = self._collection.find(filters, limit=1, sort=["-created_at"])
if results:
    return _document_to_model(results[0])
```

### 3. Ontology 在知識圖譜提取中的應用

#### 3.1 自動選擇機制

**選擇器**: `OntologySelector`

- **文件**: `kag/ontology_selector.py`
- **方法**: `select_auto(file_name, file_content, file_metadata)`
- **選擇策略**:
  1. 從文件名提取關鍵字
  2. 從文件內容預覽（前1000字符）提取關鍵字
  3. 從元數據提取文檔類型
  4. 匹配 `ontology_list.json` 中的關鍵字索引
  5. 驗證 Major 與 Domain 的兼容性

**位置**: `kg_extraction_service.py` 第 199-216 行

```python
selection = self.ontology_selector.select_auto(
    file_name=file_name,
    file_content=file_content_preview,
    file_metadata=file_metadata,
)
domain_files = selection.get("domain", [])
major_file = selection.get("major", [None])[0] if selection.get("major") else None
```

#### 3.2 合併機制

**當前實現**: 全部合併模式（Base → Domain → Major）

**合併順序**:

1. **Base Layer**: 載入基礎 Ontology
2. **Domain Layer**: 載入領域 Ontology（擴展 Base）
3. **Major Layer**: 載入專業 Ontology（擴展 Domain）

**合併邏輯**:

- **文件系統模式**: `kag/kag_schema_manager.py` 第 102-197 行
- **ArangoDB 模式**: `ontology_store_service.py` 第 523-643 行

```python
# 合併順序：base → domain → major
# 1. 載入 base ontology
base_ontology = self.get_ontology_with_priority("5W1H_Base_Ontology_OWL", "base", tenant_id)

# 2. 載入 domain ontologies
for domain_file in domain_files:
    domain_ontology = self.get_matching_ontology(domain_file, "domain", tenant_id)
    # 合併實體和關係...

# 3. 載入 major ontology
if major_file:
    major_ontology = self.get_matching_ontology(major_file, "major", tenant_id)
    # 合併實體和關係...
```

**合併結果**:

- 所有層的實體和關係都合併到一個統一的規則集中
- 後載入的層可以擴展或覆蓋前面的定義
- 最終結果包含所有層的定義

#### 3.3 Prompt 生成

**方法**: `OntologyManager.generate_prompt`

- **位置**: `kag_schema_manager.py` 第 207-272 行
- **功能**:
  - 根據合併後的 Ontology 規則生成 Prompt 模板
  - 包含實體列表、關係列表、OWL Domain/Range 約束
  - 用於 LLM 調用，指導三元組提取

```python
prompt_template = self.ontology_manager.generate_prompt(
    text_chunk=sample_text,
    ontology_rules=ontology_rules,
    include_owl_constraints=True,
)
```

#### 3.4 在文件上傳流程中的傳遞

**位置**: `api/routers/file_upload.py` 第 696-725 行

```python
# 獲取文件元數據用於 Ontology 選擇
file_metadata_obj = metadata_service.get(file_id)
file_metadata_dict = {
    "file_name": file_metadata_obj.filename,
    "file_type": file_metadata_obj.file_type,
    "file_size": file_metadata_obj.file_size,
}

# 將文件信息添加到 KG 配置中
kg_config_with_metadata = {
    **kg_config,
    "file_name": file_metadata_obj.filename,
    "file_metadata": file_metadata_dict,
}

# 傳遞給 KG 提取服務
await process_kg_extraction(
    file_id=file_id,
    chunks=chunks,
    user_id=user_id,
    options=kg_config_with_metadata,  # 包含 file_name 和 file_metadata
)
```

### 4. Ontology 合併方式分析

#### 4.1 當前實現：全部合併模式

**優點**:

- ✅ 語義完整：所有層的定義都可用
- ✅ 性能好：一次合併，O(1) 查詢
- ✅ 實現簡單：邏輯直觀
- ✅ 靈活性高：支持跨層組合

**缺點**:

- ⚠️ 可能過於寬鬆：所有層的實體/關係都可用
- ⚠️ 規則衝突處理不清晰：後載入覆蓋，但覆蓋策略不明確
- ⚠️ OWL Domain/Range 約束是追加而非替換，可能產生衝突

#### 4.2 未來改進方向：Fallback 模式（預計下個迭代）

**優點**:

- ✅ 語義更嚴格：優先使用專業層定義
- ✅ 規則清晰：優先級明確（Major > Domain > Base）
- ✅ 更符合 OWL 繼承：類似類繼承，子類優先於父類

**缺點**:

- ⚠️ 實現複雜：需要實現查詢邏輯
- ⚠️ 性能開銷：查詢時需要逐層查找
- ⚠️ Prompt 生成複雜：需要動態決定哪些實體/關係可用

#### 4.3 建議的混合方案

**實現策略**:

1. **Prompt 生成階段**: 使用全部合併（提供所有選項給 LLM）
2. **驗證階段**: 使用 Fallback（驗證提取的三元組是否符合專業層約束）
3. **OWL Domain/Range 約束**: 使用 Fallback（優先使用專業層定義）

**改進計劃**:

- 在 `merge_ontologies` 方法中添加 `mode` 參數（"merge" 或 "fallback"）
- 在 Prompt 生成時使用 "merge" 模式
- 在驗證階段使用 "fallback" 模式
- OWL Domain/Range 約束改為替換而非追加

---

## 文件上傳後顯示問題分析

### 問題描述

文件上傳成功後，文件未及時顯示在「任務工作區」的文件樹中，必須手動刷新頁面才會正常顯示。

### 問題追蹤

#### 1. 事件觸發流程

**上傳成功後的事件觸發**:

- **位置**: `ChatInput.tsx` 第 900-918 行
- **事件**: `fileUploaded` 和 `filesUploaded`

```typescript
// 觸發文件上傳完成事件
window.dispatchEvent(new CustomEvent('fileUploaded', {
  detail: { fileIds: response.data.uploaded?.map((u: any) => u.file_id) || [] }
}));

// 觸發文件樹更新事件
window.dispatchEvent(new CustomEvent('filesUploaded', {
  detail: {
    taskId: finalTaskId,
    files: response.data.uploaded.map((u: any) => ({
      file_id: u.file_id,
      filename: u.filename,
      file_type: u.file_type,
      file_size: u.file_size,
    }))
  }
}));
```

#### 2. Home 組件的事件監聽

**位置**: `Home.tsx` 第 775-892 行

**監聽事件**: `filesUploaded`, `mockFilesUploaded`

**處理邏輯**:

```typescript
const handleFilesUploadedEvent = (event: CustomEvent) => {
  const { taskId, files } = event.detail;

  setSelectedTask((currentTask) => {
    // 檢查任務ID是否匹配
    const taskIdMatch = String(currentTask.id) === String(taskId);

    if (taskIdMatch) {
      // 將文件轉換為 FileNode 格式
      const newFileNodes: FileNode[] = files.map((file: any) => ({
        id: file.file_id,
        name: file.filename,
        type: 'file' as const,
      }));

      // 更新任務的文件樹
      const updatedFileTree = currentTask.fileTree
        ? [...currentTask.fileTree, ...newFileNodes]
        : newFileNodes;

      const updatedTask = {
        ...currentTask,
        fileTree: updatedFileTree,
      };

      // 保存到 localStorage 並同步到後台
      saveTask(updatedTask, true).catch((error) => {
        console.error('[Home] Failed to save task:', error);
      });

      return updatedTask;
    }
    return currentTask;
  });
};
```

**問題點**:

1. 只更新了 `selectedTask.fileTree`，但 FileTree 組件可能沒有及時響應
2. 如果 `selectedTask` 為 `undefined`，事件不會觸發更新
3. 任務ID匹配可能失敗（字符串 vs 數字類型問題）

#### 3. FileTree 組件的事件監聽

**位置**: `FileTree.tsx` 第 2238-2303 行

**關鍵邏輯**:

```typescript
useEffect(() => {
  const currentFileTree = fileTreeRef_current.current;

  // 如果有 fileTree prop，不監聽上傳事件（由父組件管理）
  if (currentFileTree && currentFileTree.length > 0) {
    console.log('[FileTree] Has fileTree prop, skipping upload event listeners');
    return;  // ⚠️ 問題：跳過事件監聽
  }

  const handleFilesUploaded = (event: CustomEvent) => {
    const detail = event.detail;
    if (detail.taskId) {
      if (taskId && detail.taskId === taskId) {
        // 延遲 500ms 後重新加載
        setTimeout(() => {
          loadTree();
        }, 500);
      }
    }
  };

  window.addEventListener('filesUploaded', handleFilesUploaded as EventListener);
  // ...
}, [taskId, loadTree]);
```

**問題點**:

1. **如果 FileTree 使用 `fileTree` prop，會跳過事件監聽**（第 2243-2248 行）
2. **依賴於父組件（Home）更新 `fileTree` prop**，但更新可能不夠及時
3. **延遲 500ms 可能不夠**，後端可能還沒完全保存文件元數據

#### 4. 問題根因分析

**根本原因**:

1. **雙重更新機制衝突**:
   - Home 組件通過 `filesUploaded` 事件更新 `selectedTask.fileTree`
   - FileTree 組件如果有 `fileTree` prop，會跳過事件監聽，依賴 prop 更新
   - 但 prop 更新可能不夠及時，導致文件樹未刷新

2. **任務ID類型不匹配**:
   - 前端使用數字類型（`task.id: number`）
   - 後端返回字符串類型（`task_id: string`）
   - 字符串比較可能失敗：`String(currentTask.id) === String(taskId)`

3. **時序問題**:
   - 文件上傳成功後立即觸發事件
   - 但後端可能還沒完全保存文件元數據到 ArangoDB
   - FileTree 重新加載時可能查詢不到新文件

4. **新任務創建時機**:
   - 如果上傳時創建了新任務，`selectedTask` 可能還沒更新
   - `filesUploaded` 事件處理時，`currentTask` 可能為 `undefined` 或舊任務

### 解決方案建議

#### 方案 1: 強制刷新機制（推薦）

在 `filesUploaded` 事件處理中，強制觸發 FileTree 重新加載：

```typescript
// Home.tsx
const handleFilesUploadedEvent = (event: CustomEvent) => {
  const { taskId, files } = event.detail;

  // 更新 selectedTask.fileTree
  setSelectedTask((currentTask) => {
    // ... 現有邏輯 ...
  });

  // 強制觸發 FileTree 更新事件
  window.dispatchEvent(new CustomEvent('fileTreeUpdated', {
    detail: {
      taskId: taskId,
      forceReload: true,  // 強制重新加載
      newFiles: files
    }
  }));
};
```

#### 方案 2: 增加延遲時間

將 FileTree 的延遲從 500ms 增加到 1000-1500ms：

```typescript
// FileTree.tsx
setTimeout(() => {
  loadTree();
}, 1500);  // 增加到 1.5 秒
```

#### 方案 3: 輪詢機制

在文件上傳成功後，輪詢檢查文件是否已出現在文件樹中：

```typescript
// 輪詢檢查文件是否已存在
const pollFileExists = async (fileId: string, maxAttempts = 10) => {
  for (let i = 0; i < maxAttempts; i++) {
    await new Promise(resolve => setTimeout(resolve, 500));
    const exists = await checkFileExists(fileId);
    if (exists) {
      // 觸發文件樹刷新
      window.dispatchEvent(new CustomEvent('fileTreeUpdated', {
        detail: { forceReload: true }
      }));
      break;
    }
  }
};
```

#### 方案 4: 統一事件處理（長期方案）

統一使用 `fileTreeUpdated` 事件，而不是多個不同的事件：

```typescript
// 統一的事件格式
window.dispatchEvent(new CustomEvent('fileTreeUpdated', {
  detail: {
    taskId: finalTaskId,
    action: 'upload',  // 'upload' | 'delete' | 'move' | 'rename'
    files: uploadedFiles,
    forceReload: true,
  }
}));
```

### 當前臨時解決方案

**用戶操作**: 手動刷新頁面（F5 或 Cmd+R）

**開發建議**:

1. 在文件上傳成功後，顯示提示信息："文件上傳成功，正在刷新文件樹..."
2. 自動觸發一次文件樹刷新（延遲 1-2 秒）
3. 如果刷新後仍看不到文件，提示用戶手動刷新

---

## 相關服務和依賴

### 前端服務

1. **FileUploadModal** (`ai-bot/src/components/FileUploadModal.tsx`)
   - 文件選擇和驗證
   - 拖拽上傳支持
   - 圖片預覽

2. **UploadProgress** (`ai-bot/src/components/UploadProgress.tsx`)
   - 上傳進度顯示

3. **API Client** (`ai-bot/src/lib/api.ts`)
   - `uploadFiles` 函數
   - 進度回調支持

4. **FileTree** (`ai-bot/src/components/FileTree.tsx`)
   - 文件樹顯示
   - 文件操作（重命名、移動、刪除等）

5. **Home** (`ai-bot/src/pages/Home.tsx`)
   - 任務管理
   - 文件樹狀態管理
   - 事件監聽和處理

### 後端服務

1. **FileValidator** (`services/api/utils/file_validator.py`)
   - 文件類型驗證
   - 文件大小驗證

2. **FileStorage** (`storage/file_storage.py`)
   - 文件物理存儲
   - 支持多種存儲後端（本地、S3等）

3. **FileMetadataService** (`services/api/services/file_metadata_service.py`)
   - 文件元數據管理
   - ArangoDB 存儲

4. **UserTaskService** (`services/api/services/user_task_service.py`)
   - 任務管理
   - 任務工作區創建

5. **TaskWorkspaceService** (`services/api/services/task_workspace_service.py`)
   - 任務工作區管理

6. **FilePermissionService** (`services/api/services/file_permission_service.py`)
   - 文件權限檢查

7. **EmbeddingService** (`services/api/services/embedding_service.py`)
   - 向量生成

8. **VectorStoreService** (`services/api/services/vector_store_service.py`)
   - 向量存儲到 ChromaDB

9. **KGExtractionService** (`services/api/services/kg_extraction_service.py`)
   - 知識圖譜提取
   - Ontology 載入和應用

10. **OntologyStoreService** (`services/api/services/ontology_store_service.py`)
    - Ontology CRUD 操作
    - Ontology 合併
    - 多租戶支持

11. **OntologyManager** (`kag/kag_schema_manager.py`)
    - Ontology 載入和合併（文件系統模式）
    - Prompt 生成

12. **OntologySelector** (`kag/ontology_selector.py`)
    - Ontology 自動選擇
    - 關鍵字匹配

13. **UploadStatusService** (`services/api/services/upload_status_service.py`)
    - 上傳和處理狀態管理

---

## 文件存儲後端說明

### 存儲後端選擇

系統支持兩種存儲後端：

1. **本地文件系統** (`LocalFileStorage`)：
   - 用於開發和測試環境
   - 文件存儲在 `./data/datasets/files`
   - `file_path` 返回本地文件路徑

2. **SeaweedFS/S3** (`S3FileStorage`)：
   - 用於生產環境，支持 Kubernetes 無狀態擴展
   - 文件存儲在 SeaweedFS 分布式文件系統
   - `file_path` 返回 S3 URI（格式：`s3://bucket/key`）

### 配置優先級

存儲後端的選擇通過配置決定，優先級如下：

1. **S3/SeaweedFS**（如果配置了 SeaweedFS 環境變數）
2. **本地文件系統**（fallback）

### S3 URI 格式說明

當使用 SeaweedFS 存儲時，`file_path` 字段返回 S3 URI：

- **格式**: `s3://{bucket}/{key}`
- **示例**: `s3://bucket-ai-box-assets/tasks/task-123/file-id.pdf`
- **Bucket 選擇**:
  - AI-Box 服務：`bucket-ai-box-assets`（默認）
  - DataLake 服務：`bucket-datalake-assets`（用於文件備份）

### 響應格式示例

**使用 SeaweedFS 時的響應**：

```json
{
  "success": true,
  "message": "所有文件上傳成功（1 個文件）",
  "data": {
    "uploaded": [
      {
        "file_id": "file-uuid-123",
        "filename": "document.pdf",
        "file_type": "application/pdf",
        "file_size": 1024000,
        "file_path": "s3://bucket-ai-box-assets/tasks/task-456/file-uuid-123.pdf",
        "task_id": "task-456",
        "folder_id": null
      }
    ],
    "errors": [],
    "total": 1,
    "success_count": 1,
    "error_count": 0,
    "task_id": "task-456"
  }
}
```

**使用本地文件系統時的響應**：

```json
{
  "success": true,
  "message": "所有文件上傳成功（1 個文件）",
  "data": {
    "uploaded": [
      {
        "file_id": "file-uuid-123",
        "filename": "document.pdf",
        "file_type": "application/pdf",
        "file_size": 1024000,
        "file_path": "./data/datasets/files/tasks/task-456/file-uuid-123.pdf",
        "task_id": "task-456",
        "folder_id": null
      }
    ],
    "errors": [],
    "total": 1,
    "success_count": 1,
    "error_count": 0,
    "task_id": "task-456"
  }
}
```

---

## API 端點總結

### 主要端點

1. **POST `/api/v1/files/upload`**
   - 文件上傳
   - 參數: `files` (multipart), `task_id` (form), `target_folder_id` (form)
   - 返回: 上傳結果和文件ID，包含 S3 URI（如果使用 SeaweedFS）或本地路徑（如果使用本地存儲）
   - 位置: `api/routers/file_upload.py` 第 1624-2064 行
   - **存儲後端**: 支持本地文件系統（LocalFileStorage）和 SeaweedFS（S3FileStorage）
   - **返回格式**: `file_path` 字段為 S3 URI（格式：`s3://bucket/key`）或本地文件路徑

### 輔助端點

2. **GET `/api/v1/files/upload/{file_id}/progress`**
   - 查詢上傳進度
   - 位置: `file_upload.py` 第 2112-2152 行

3. **GET `/api/v1/files/{file_id}/processing-status`**
   - 查詢處理狀態（分塊、向量化、KG提取）
   - 位置: `file_upload.py` 第 2155-2259 行

4. **GET `/api/v1/files/{file_id}/kg/chunk-status`**
   - 查詢 KG 分塊續跑狀態
   - 位置: `file_upload.py` 第 2262-2311 行

5. **GET `/api/v1/files/tree`**
   - 獲取文件樹結構
   - 參數: `user_id`, `task_id`
   - 位置: `api/routers/file_management.py`

---

## 數據流

### 請求流程

```
前端 FormData
  ↓
FastAPI multipart 解析
  ↓
文件驗證 (FileValidator)
  ↓
文件存儲 (FileStorage)
  ↓
元數據創建 (FileMetadataService → ArangoDB)
  ↓
異步任務提交 (RQ Queue)
  ↓
返回響應（包含 file_id）
  ↓
前端觸發 filesUploaded 事件
  ↓
Home 組件更新 selectedTask.fileTree
  ↓
FileTree 組件接收 fileTree prop 更新（或重新加載）
```

### 異步處理流程

```
RQ Worker 接收任務
  ↓
文件解析和分塊
  ↓
向量化 (EmbeddingService)
  ↓
存儲向量 (VectorStoreService → ChromaDB)
  ↓
Ontology 自動選擇 (OntologySelector)
  ↓
Ontology 載入和合併 (OntologyManager/OntologyStoreService)
  ↓
知識圖譜提取 (KGExtractionService)
  ↓
更新處理狀態 (Redis + ArangoDB)
```

---

## 已知問題與改進計劃

### 已知問題

#### 1. 文件上傳後未及時顯示（高優先級）

**問題**: 文件上傳成功後，文件未及時顯示在「任務工作區」的文件樹中，必須手動刷新頁面才會正常顯示。

**根因**:

- FileTree 組件如果有 `fileTree` prop，會跳過事件監聽
- Home 組件更新 `fileTree` prop 可能不夠及時
- 後端保存文件元數據需要時間，延遲 500ms 可能不夠

**臨時解決方案**: 用戶手動刷新頁面

**改進計劃**:

- 增加延遲時間到 1-2 秒
- 實現輪詢機制檢查文件是否存在
- 統一事件處理機制
- 強制觸發 FileTree 重新加載

#### 2. Ontology 合併方式（中優先級）

**當前實現**: 全部合併模式（Base → Domain → Major）

**問題**:

- OWL Domain/Range 約束是追加而非替換，可能產生衝突
- 規則衝突處理不清晰

**改進計劃**（預計下個迭代）:

- 實現混合模式：Prompt 生成使用全部合併，驗證使用 Fallback
- OWL Domain/Range 約束改為替換而非追加
- 明確同名定義的覆蓋策略

#### 3. 任務ID類型不匹配（低優先級）

**問題**: 前端使用數字類型，後端返回字符串類型，可能導致匹配失敗。

**改進計劃**:

- 統一使用字符串類型
- 改進類型轉換邏輯

### 改進計劃

#### 短期改進（1-2 週）

1. **文件上傳後顯示問題**
   - 增加延遲時間
   - 實現強制刷新機制
   - 添加用戶提示

2. **錯誤處理改進**
   - 更詳細的錯誤信息
   - 重試機制

#### 中期改進（1-2 個月）

1. **Ontology 合併方式優化**
   - 實現混合模式
   - OWL 約束處理改進
   - 規則衝突處理

2. **性能優化**
   - 文件樹緩存機制
   - 增量更新機制

#### 長期改進（3-6 個月）

1. **統一事件系統**
   - 統一事件格式
   - 事件總線機制

2. **實時更新機制**
   - WebSocket 支持
   - 服務器推送更新

---

## 更新記錄

- **2025-01-27**: 初始版本，追蹤完整文件上傳流程
- **2025-12-08**: 添加文件創建操作日誌
- **2025-12-12**: 改進文件讀取邏輯，支持從元數據獲取 task_id 和 storage_path
- **2025-12-13**: 添加 KG 分塊續跑功能
- **2025-12-14**: 添加空白 Markdown 文件創建端點
- **2025-12-18**: Ontology 遷移到 ArangoDB 存儲
- **2025-12-19**: v2.0 版本，強化 Ontology 說明，添加文件上傳後顯示問題分析

---

## 附錄

### A. 相關文件列表

#### 前端文件

- `ai-bot/src/components/ChatInput.tsx` - 聊天輸入框組件
- `ai-bot/src/components/FileUploadModal.tsx` - 文件上傳模態框
- `ai-bot/src/components/UploadProgress.tsx` - 上傳進度組件
- `ai-bot/src/components/FileTree.tsx` - 文件樹組件
- `ai-bot/src/pages/Home.tsx` - 主頁組件（任務和文件樹管理）
- `ai-bot/src/lib/api.ts` - API 客戶端

#### 後端文件

- `api/routers/file_upload.py` - 文件上傳路由
- `api/main.py` - FastAPI 主入口（路由註冊）
- `workers/tasks.py` - RQ 任務定義
- `services/api/services/file_metadata_service.py` - 文件元數據服務
- `services/api/services/user_task_service.py` - 用戶任務服務
- `services/api/services/task_workspace_service.py` - 任務工作區服務
- `services/api/services/file_permission_service.py` - 文件權限服務
- `services/api/services/embedding_service.py` - 向量化服務
- `services/api/services/vector_store_service.py` - 向量存儲服務
- `services/api/services/kg_extraction_service.py` - 知識圖譜提取服務
- `services/api/services/ontology_store_service.py` - Ontology 存儲服務
- `services/api/services/upload_status_service.py` - 上傳狀態服務
- `storage/file_storage.py` - 文件存儲抽象層
- `services/api/utils/file_validator.py` - 文件驗證工具
- `kag/kag_schema_manager.py` - Ontology 管理器（文件系統模式）
- `kag/ontology_selector.py` - Ontology 選擇器

### B. 關鍵配置

#### 前端配置

- **API Base URL**: `VITE_API_BASE_URL` 或默認 `http://localhost:8000`
- **API Prefix**: `VITE_API_PREFIX` 或默認 `/api/v1`

#### 後端配置

- **文件上傳配置**: `config/config.json` → `file_upload` 區塊
- **服務配置**: `config/config.json` → `services` 區塊
  - `kg_extraction.enabled`: 是否啟用知識圖譜提取
  - `kg_extraction.mode`: 提取模式（`all_chunks`, `selected_chunks`, `entire_file`）
  - `kg_extraction.min_confidence`: 最小置信度閾值
- **存儲配置**: `config/config.json` → `storage` 區塊
- **ArangoDB 配置**: `.env` → `ARANGODB_*` 環境變數

### C. 注意事項

1. **任務關聯**: 所有文件必須關聯到任務工作區（不再支持 `temp-workspace`）
2. **異步處理**: 文件上傳成功後，處理任務在後台異步執行
3. **進度追蹤**: 上傳進度由前端 XMLHttpRequest 追蹤，處理進度由 Redis 存儲
4. **圖片文件**: 圖片文件使用視覺模型生成描述，跳過知識圖譜提取
5. **多文件上傳**: 支持一次上傳多個文件，每個文件獨立處理
6. **Ontology 支持**: 如果 Ontology 模組不可用，會降級為不使用 Ontology 的模式
7. **多租戶**: Ontology 支持多租戶隔離，租戶專屬 Ontology 優先於全局共享

---

## 參考文檔

- ArangoDB 數據存儲規範: `.cursor/rules/develop-rule.mdc` → ArangoDB 數據存儲規範
- Ontology 合併邏輯: `kag/kag_schema_manager.py` 第 102-197 行
- Ontology 存儲服務: `services/api/services/ontology_store_service.py`
- 知識圖譜提取服務: `services/api/services/kg_extraction_service.py`
