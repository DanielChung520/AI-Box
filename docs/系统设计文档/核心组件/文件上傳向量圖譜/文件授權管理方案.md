# 文件授權管理方案

**創建日期**: 2026-01-02
**創建人**: Daniel Chung
**最後修改日期**: 2026-01-02

---

## 📋 概述

本文檔基於 AI 治理原則，詳細說明 AI-Box 系統中文件授權管理（Access Control）的設計方案，包括訪問級別、權限檢查邏輯、數據分類與敏感性標籤、以及向量和知識圖譜的訪問控制。

### 設計原則

1. **最小權限原則**：默認私有，按需授權
2. **數據分類驅動**：結合數據分類級別與訪問控制
3. **分層授權**：全局 → 組織 → 安全組 → 用戶
4. **審計與合規**：記錄所有訪問操作
5. **動態授權**：支持運行時權限檢查

---

## 🎯 訪問級別定義

### 訪問級別枚舉

```python
class FileAccessLevel(str, Enum):
    """文件訪問級別枚舉"""
    
    PUBLIC = "public"  # 全局公開：全公司可見
    ORGANIZATION = "organization"  # 組織級：授權組織部分可見
    SECURITY_GROUP = "security_group"  # 安全組級：特定安全組授權
    PRIVATE = "private"  # 私有：只有授權用戶可見（默認）
```

### 訪問級別使用場景

| 訪問級別 | 使用場景 | 數據分類建議 | 示例 |
|---------|---------|------------|------|
| **PUBLIC** | 全公司公開文檔 | `PUBLIC` | 公司公告、公開政策文檔 |
| **ORGANIZATION** | 部門/組織共享 | `INTERNAL` | 部門內部文檔、組織級知識庫 |
| **SECURITY_GROUP** | 特定項目/安全組 | `CONFIDENTIAL` | 項目文檔、安全組知識庫 |
| **PRIVATE** | 個人文檔 | `INTERNAL` 或 `CONFIDENTIAL` | 個人筆記、私有文檔 |

---

## 📊 數據模型設計

### 1. FileAccessControl 模型

```python
class FileAccessControl(BaseModel):
    """文件訪問控制模型"""
    
    # 訪問級別（優先級從高到低）
    access_level: str = Field(
        ...,
        description="訪問級別: PUBLIC | ORGANIZATION | SECURITY_GROUP | PRIVATE"
    )
    
    # 組織級授權（access_level = ORGANIZATION）
    authorized_organizations: Optional[List[str]] = Field(
        None,
        description="授權組織ID列表（僅當 access_level=ORGANIZATION 時使用）"
    )
    
    # 安全組級授權（access_level = SECURITY_GROUP）
    authorized_security_groups: Optional[List[str]] = Field(
        None,
        description="授權安全組ID列表（僅當 access_level=SECURITY_GROUP 時使用）"
    )
    
    # 用戶級授權（access_level = PRIVATE）
    authorized_users: Optional[List[str]] = Field(
        None,
        description="授權用戶ID列表（僅當 access_level=PRIVATE 時使用，默認包含 owner）"
    )
    
    # 數據分類（AI治理要求）
    data_classification: Optional[str] = Field(
        default="internal",
        description="數據分類級別: public | internal | confidential | restricted"
    )
    
    # 敏感性標籤（AI治理要求）
    sensitivity_labels: Optional[List[str]] = Field(
        default_factory=list,
        description="敏感性標籤列表: PII, PHI, FINANCIAL, IP, CUSTOMER, PROPRIETARY"
    )
    
    # 所有者信息
    owner_id: str = Field(..., description="文件所有者用戶ID")
    owner_tenant_id: Optional[str] = Field(None, description="文件所有者租戶ID")
    
    # 審計字段
    access_log_enabled: bool = Field(
        default=True,
        description="是否啟用訪問日誌（AI治理要求）"
    )
    
    # 過期時間（可選）
    access_expires_at: Optional[datetime] = Field(
        None,
        description="訪問權限過期時間（可選，用於臨時授權）"
    )
```

### 2. 擴展 FileMetadata 模型

```python
class FileMetadata(FileMetadataBase):
    """擴展的文件元數據模型"""
    
    # ... 現有字段 ...
    
    # 訪問控制（新增）
    access_control: FileAccessControl = Field(
        ...,
        description="文件訪問控制配置"
    )
    
    # 數據分類（與 access_control 中的 data_classification 保持一致）
    data_classification: Optional[str] = Field(
        None,
        description="數據分類級別（與 access_control.data_classification 同步）"
    )
    
    # 敏感性標籤（與 access_control 中的 sensitivity_labels 保持一致）
    sensitivity_labels: Optional[List[str]] = Field(
        default_factory=list,
        description="敏感性標籤列表（與 access_control.sensitivity_labels 同步）"
    )
```

---

## 🔐 權限檢查邏輯

### 1. 核心檢查方法

```python
class FilePermissionService:
    """擴展的文件權限檢查服務"""
    
    def check_file_access_with_acl(
        self,
        user: User,
        file_metadata: FileMetadata,
        required_permission: str = Permission.FILE_READ.value,
    ) -> bool:
        """
        基於訪問控制列表（ACL）檢查文件訪問權限
        
        AI治理原則：
        1. 最小權限原則：默認拒絕，明確授權
        2. 數據分類檢查：用戶權限級別必須匹配或高於文件分類級別
        3. 分層授權：按優先級檢查（PUBLIC → ORGANIZATION → SECURITY_GROUP → PRIVATE）
        4. 審計日誌：記錄所有訪問嘗試
        
        Args:
            user: 當前用戶
            file_metadata: 文件元數據（包含 access_control）
            required_permission: 需要的權限
            
        Returns:
            bool: 是否有權限訪問
        """
        access_control = file_metadata.access_control
        
        # 1. 檢查訪問權限是否過期
        if access_control.access_expires_at:
            if datetime.utcnow() > access_control.access_expires_at:
                self._log_access_denied(
                    user, file_metadata, "Access expired",
                    required_permission
                )
                return False
        
        # 2. 數據分類級別檢查（AI治理要求）
        if not self._check_data_classification_access(
            user, access_control.data_classification
        ):
            self._log_access_denied(
                user, file_metadata, 
                f"Insufficient clearance for {access_control.data_classification}",
                required_permission
            )
            return False
        
        # 3. 敏感性標籤檢查（AI治理要求）
        if not self._check_sensitivity_labels_access(
            user, access_control.sensitivity_labels
        ):
            self._log_access_denied(
                user, file_metadata,
                f"User lacks required sensitivity label access",
                required_permission
            )
            return False
        
        # 4. 按訪問級別檢查權限（優先級從高到低）
        access_level = access_control.access_level
        
        # 4.1 PUBLIC：全公司可見
        if access_level == FileAccessLevel.PUBLIC:
            if user.has_permission(Permission.FILE_READ.value):
                self._log_access_granted(user, file_metadata, "PUBLIC access")
                return True
        
        # 4.2 ORGANIZATION：組織級授權
        elif access_level == FileAccessLevel.ORGANIZATION:
            user_org_id = self._get_user_organization_id(user)
            if user_org_id in (access_control.authorized_organizations or []):
                if user.has_permission(Permission.FILE_READ.value):
                    self._log_access_granted(user, file_metadata, "ORGANIZATION access")
                    return True
        
        # 4.3 SECURITY_GROUP：安全組級授權
        elif access_level == FileAccessLevel.SECURITY_GROUP:
            user_security_groups = self._get_user_security_groups(user)
            authorized_groups = access_control.authorized_security_groups or []
            if any(g in authorized_groups for g in user_security_groups):
                if user.has_permission(Permission.FILE_READ.value):
                    self._log_access_granted(user, file_metadata, "SECURITY_GROUP access")
                    return True
        
        # 4.4 PRIVATE：私有（默認）
        elif access_level == FileAccessLevel.PRIVATE:
            # 檢查用戶是否為文件所有者
            if file_metadata.user_id == user.user_id:
                self._log_access_granted(user, file_metadata, "OWNER access")
                return True
            
            # 檢查用戶是否在授權用戶列表中
            authorized_users = access_control.authorized_users or []
            if user.user_id in authorized_users:
                if user.has_permission(Permission.FILE_READ.value):
                    self._log_access_granted(user, file_metadata, "PRIVATE authorized access")
                    return True
        
        # 5. 默認拒絕（最小權限原則）
        self._log_access_denied(
            user, file_metadata, 
            f"Access level {access_level} check failed",
            required_permission
        )
        return False
```

### 2. 數據分類級別檢查

```python
def _check_data_classification_access(
    self,
    user: User,
    file_classification: str,
) -> bool:
    """
    檢查用戶是否有權限訪問指定分類級別的數據
    
    AI治理原則：用戶權限級別必須匹配或高於文件分類級別
    
    權限級別映射：
    - PUBLIC: 所有用戶可訪問
    - INTERNAL: 需要內部用戶權限
    - CONFIDENTIAL: 需要機密訪問權限
    - RESTRICTED: 需要限制訪問權限（最高級別）
    """
    # 超級管理員可以訪問所有級別
    if user.has_permission(Permission.ALL.value):
        return True
    
    # 權限級別映射
    classification_permissions = {
        DataClassification.PUBLIC.value: [],  # 無需特殊權限
        DataClassification.INTERNAL.value: ["data:access:internal"],
        DataClassification.CONFIDENTIAL.value: ["data:access:confidential"],
        DataClassification.RESTRICTED.value: ["data:access:restricted"],
    }
    
    required_permissions = classification_permissions.get(
        file_classification, 
        ["data:access:internal"]  # 默認需要內部權限
    )
    
    # 如果無需特殊權限，直接允許
    if not required_permissions:
        return True
    
    # 檢查用戶是否擁有所需權限
    return user.has_any_permission(*required_permissions)
```

### 3. 敏感性標籤檢查

```python
def _check_sensitivity_labels_access(
    self,
    user: User,
    file_sensitivity_labels: List[str],
) -> bool:
    """
    檢查用戶是否有權限訪問包含特定敏感性標籤的數據
    
    AI治理原則：用戶必須擁有對應敏感性標籤的訪問權限
    """
    if not file_sensitivity_labels:
        return True  # 無敏感性標籤，直接允許
    
    # 超級管理員可以訪問所有標籤
    if user.has_permission(Permission.ALL.value):
        return True
    
    # 檢查用戶是否擁有所有所需標籤的訪問權限
    for label in file_sensitivity_labels:
        required_permission = f"data:label:{label}"
        if not user.has_permission(required_permission):
            return False
    
    return True
```

---

## 🔍 向量和知識圖譜的訪問控制

### 1. 向量檢索時的權限過濾

```python
def query_vectors_with_acl(
    self,
    query_text: str,
    user: User,
    n_results: int = 10,
    **kwargs
) -> List[Dict[str, Any]]:
    """
    帶訪問控制權限檢查的向量檢索
    
    AI治理要求：
    1. 只返回用戶有權限訪問的文件向量
    2. 根據文件訪問級別過濾結果
    """
    # 1. 執行向量檢索
    results = self.query(query_text, n_results=n_results * 2, **kwargs)  # 多檢索一些，用於過濾
    
    # 2. 獲取文件元數據並檢查權限
    filtered_results = []
    permission_service = get_file_permission_service()
    
    for result in results:
        file_id = result.get("metadata", {}).get("file_id")
        if not file_id:
            continue
        
        # 獲取文件元數據
        file_metadata = self.metadata_service.get(file_id)
        if not file_metadata:
            continue
        
        # 檢查訪問權限
        if permission_service.check_file_access_with_acl(
            user=user,
            file_metadata=file_metadata,
            required_permission=Permission.FILE_READ.value,
        ):
            filtered_results.append(result)
            
            if len(filtered_results) >= n_results:
                break
    
    return filtered_results
```

### 2. 知識圖譜查詢時的權限過濾

```python
def query_kg_with_acl(
    self,
    query: str,
    user: User,
    **kwargs
) -> List[Dict[str, Any]]:
    """
    帶訪問控制權限檢查的知識圖譜查詢
    
    AI治理要求：
    1. 只返回用戶有權限訪問的文件知識圖譜數據
    2. 根據文件訪問級別過濾實體和關係
    """
    # 1. 執行知識圖譜查詢
    kg_results = self.query_kg(query, **kwargs)
    
    # 2. 獲取關聯的文件ID並檢查權限
    permission_service = get_file_permission_service()
    filtered_results = []
    
    for result in kg_results:
        file_id = result.get("file_id")
        if not file_id:
            continue
        
        # 獲取文件元數據
        file_metadata = self.metadata_service.get(file_id)
        if not file_metadata:
            continue
        
        # 檢查訪問權限
        if permission_service.check_file_access_with_acl(
            user=user,
            file_metadata=file_metadata,
            required_permission=Permission.FILE_READ.value,
        ):
            filtered_results.append(result)
    
    return filtered_results
```

---

## 📝 默認策略

### 文件上傳時的默認訪問控制配置

```python
def get_default_access_control(
    user: User,
    tenant_id: Optional[str] = None,
) -> FileAccessControl:
    """
    獲取默認的文件訪問控制配置
    
    AI治理原則：默認私有，最小權限
    """
    return FileAccessControl(
        access_level=FileAccessLevel.PRIVATE,  # 默認私有
        owner_id=user.user_id,
        owner_tenant_id=tenant_id,
        data_classification=DataClassification.INTERNAL.value,  # 默認內部
        sensitivity_labels=[],
        authorized_users=[user.user_id],  # 默認只有所有者
    )
```

---

## 🔐 權限枚舉擴展

### 建議的權限枚舉擴展

```python
# system/security/models.py

class Permission(str, Enum):
    # ... 現有權限 ...
    
    # 數據訪問權限（AI治理要求）
    DATA_ACCESS_INTERNAL = "data:access:internal"  # 內部數據訪問
    DATA_ACCESS_CONFIDENTIAL = "data:access:confidential"  # 機密數據訪問
    DATA_ACCESS_RESTRICTED = "data:access:restricted"  # 限制數據訪問
    
    # 敏感性標籤訪問權限
    DATA_LABEL_PII = "data:label:pii"  # PII 標籤訪問
    DATA_LABEL_PHI = "data:label:phi"  # PHI 標籤訪問
    DATA_LABEL_FINANCIAL = "data:label:financial"  # 財務標籤訪問
    DATA_LABEL_IP = "data:label:ip"  # IP 標籤訪問
    DATA_LABEL_CUSTOMER = "data:label:customer"  # 客戶標籤訪問
    DATA_LABEL_PROPRIETARY = "data:label:proprietary"  # 專有標籤訪問
```

---

## 📋 實施建議

### 階段一：基礎模型擴展（優先級：高）

1. 擴展 `FileMetadata` 模型，添加 `access_control` 字段
2. 創建 `FileAccessControl` 模型
3. 更新 `FileMetadataService` 支持訪問控制字段

### 階段二：權限檢查邏輯（優先級：高）

1. 擴展 `FilePermissionService`，實現 `check_file_access_with_acl`
2. 實現數據分類和敏感性標籤檢查
3. 實現組織和安全組查詢邏輯

### 階段三：向量和圖譜權限過濾（優先級：中）

1. 在向量檢索時添加權限過濾
2. 在知識圖譜查詢時添加權限過濾
3. 確保 RAG 檢索結果符合訪問控制

### 階段四：審計和合規（優先級：中）

1. 實現訪問日誌記錄
2. 實現訪問審計報告
3. 實現合規性檢查

---

## ✅ AI 治理合規性

### 合規性要求

1. **數據分類**：使用 `DataClassification` 枚舉
2. **敏感性標籤**：使用 `SensitivityLabel` 枚舉
3. **最小權限**：默認私有，按需授權
4. **訪問審計**：記錄所有訪問操作
5. **權限過期**：支持臨時授權

### 與現有系統集成

1. **多租戶**：通過 `tenant_id` 實現租戶隔離
2. **數據分類**：復用 `DataClassification` 和 `SensitivityLabel`
3. **權限模型**：擴展 `Permission` 枚舉，添加數據訪問權限
4. **審計日誌**：使用 `audit_logs` collection 記錄訪問

---

## 📚 相關文檔

- [上傳的功能架構說明-v3.0](./上傳的功能架構說明-v3.0.md) - 主架構文檔
- [文件授權管理實施計劃](./文件授權管理實施計劃.md) - 詳細的實施計劃和時間表
- [安全架構說明](../../安全架构说明.md) - 系統安全架構
- [數據分類模型](../../../services/api/models/data_classification.py) - 數據分類定義

---

**最後更新日期**: 2026-01-02

