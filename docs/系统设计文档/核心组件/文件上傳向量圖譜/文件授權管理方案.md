# 文件授權管理方案

**創建日期**: 2026-01-02
**創建人**: Daniel Chung
**最後修改日期**: 2026-01-28

---

## 📌 需求對齊：文件權限 vs data_consents（2026-01-28）

以下對齊「文件權限／授權同意」的表述與現有實作，避免混淆。

| 需求表述 | 實作位置 | 說明 |
|----------|----------|------|
| 上傳文件時，每個文件默認權限＝自己 | **file_metadata.access_control** | 上傳時自動寫入 `get_default_access_control(user_id)`：`access_level=PRIVATE`、`authorized_users=[user_id]`。**不寫入 data_consents 集合**。 |
| 前端文件權限設置：公開／其他權限、增加被授權 user 或 Security group | **file_metadata.access_control** | 前端「設置權限」寫入並更新 `file_metadata.access_control`（access_level、authorized_users、authorized_security_groups 等）。 |
| 查詢文件知識庫時，安全審計＝看當前 user 或 Security group 有沒有權限看文件 | **查 file_metadata.access_control** | 透過 `FilePermissionService.check_file_access_with_acl(user, file_metadata)` 檢查；向量檢索使用 `query_vectors_with_acl`，只回傳有權限的文件。**不查 data_consents 集合**。 |
| 用戶級「同意」（例如同意 AI 處理數據） | **data_consents 集合** | 存用戶級同意，如 `_key: {user_id}_ai_processing`、`granted`、`purpose` 等。與「文件級授權」分開。 |

**結論**：  
- **文件級授權（誰可以看哪個文件）**：存於 **file_metadata.access_control**，查詢知識庫時的安全審計依此判斷。  
- **data_consents**：僅存**用戶級同意**（如 AI 處理同意），不存文件級授權。  
若未來希望「文件授權」也集中到 data_consents 集合，可再擴充 document 型別（例如 `file_access`）並遷移；目前以 file_metadata.access_control 為準。

---

## 🖥️ 前端頁面操作（2026-01-28 新增）

授權管理的前端操作與後端 **access_control** 一一對應，以下為入口、組件與 API 說明。

### 1. 入口與組件

| 項目 | 說明 |
|------|------|
| **入口** | 文件樹中對某文件**右鍵 →「設置權限」**（或目錄右鍵同項，依實作） |
| **組件** | `ai-bot/src/components/FileAccessControlModal.tsx`（FileAccessControlModal） |
| **觸發** | FileTree 內 `FileAccessControlModal`，傳入 `fileId`、`fileName`、`ownerId`，`onSuccess` 時刷新文件樹 |

### 2. 彈窗內欄位與 access_control 對應

Modal 內所有可編輯項均對應 **file_metadata.access_control** 的欄位，讀寫一致：

| 前端欄位（Modal 內） | access_control 欄位 | 說明 |
|----------------------|----------------------|------|
| 訪問級別 | `access_level` | PUBLIC / ORGANIZATION / SECURITY_GROUP / PRIVATE |
| 授權組織列表 | `authorized_organizations` | 當 access_level = ORGANIZATION 時使用 |
| 授權安全組列表 | `authorized_security_groups` | 當 access_level = SECURITY_GROUP 時使用 |
| 授權用戶列表 | `authorized_users` | 當 access_level = PRIVATE 時使用（預設含 owner） |
| 數據分類 | `data_classification` | PUBLIC / INTERNAL / CONFIDENTIAL / RESTRICTED |
| 敏感性標籤 | `sensitivity_labels` | PII, PHI, FINANCIAL, IP, CUSTOMER, PROPRIETARY 等 |
| 所有者 | `owner_id` | 唯讀，來自文件元數據 |
| 訪問權限過期時間 | `access_expires_at` | 可選，ISO 8601 |
| 是否啟用訪問日誌 | `access_log_enabled` | 布林 |

### 3. API 調用

| 操作 | API（前端 ai-bot/src/lib/api.ts） | 後端行為 |
|------|-----------------------------------|----------|
| **打開彈窗、載入現有配置** | `getFileAccessControl(fileId)` | 回傳該文件的 `access_control`，Modal 依此渲染各欄位 |
| **儲存** | `updateFileAccessControl(fileId, acl)` | 請求體為 `{ access_control: acl }`，後端更新 `file_metadata.access_control` |

### 4. 操作流程簡述

1. 使用者在文件樹對某文件右鍵，選擇「設置權限」。
2. Modal 打開時呼叫 `getFileAccessControl(fileId)`，取得並顯示當前 access_control。
3. 使用者可修改：訪問級別、授權組織／安全組／用戶、數據分類、敏感性標籤、過期時間、訪問日誌開關等。
4. 點擊儲存後呼叫 `updateFileAccessControl(fileId, acl)`，將整份 **FileAccessControl** 寫回後端。
5. 後端更新 **file_metadata.access_control**；`onSuccess` 後前端刷新文件樹（必要時可再拉一次列表）。

以上即為授權管理方案中與**前端頁面操作**相關的完整對應；所有授權欄位均以 **access_control** 為單一來源與寫入目標。

---

## 📋 概述

本文檔基於 AI 治理原則，詳細說明 AI-Box 系統中文件授權管理（Access Control）的設計方案，包括訪問級別、權限檢查邏輯、數據分類與敏感性標籤、以及向量和知識圖譜的訪問控制。

### 設計原則

1. **最小權限原則**：默認私有，按需授權
2. **數據分類驅動**：結合數據分類級別與訪問控制
3. **分層授權**：全局 → 組織 → 安全組 → 用戶
4. **審計與合規**：記錄所有訪問操作
5. **動態授權**：支持運行時權限檢查

---

## 🎯 訪問級別定義

### 訪問級別枚舉

```python
class FileAccessLevel(str, Enum):
    """文件訪問級別枚舉"""
    
    PUBLIC = "public"  # 全局公開：全公司可見
    ORGANIZATION = "organization"  # 組織級：授權組織部分可見
    SECURITY_GROUP = "security_group"  # 安全組級：特定安全組授權
    PRIVATE = "private"  # 私有：只有授權用戶可見（默認）
```

### 訪問級別使用場景

| 訪問級別 | 使用場景 | 數據分類建議 | 示例 |
|---------|---------|------------|------|
| **PUBLIC** | 全公司公開文檔 | `PUBLIC` | 公司公告、公開政策文檔 |
| **ORGANIZATION** | 部門/組織共享 | `INTERNAL` | 部門內部文檔、組織級知識庫 |
| **SECURITY_GROUP** | 特定項目/安全組 | `CONFIDENTIAL` | 項目文檔、安全組知識庫 |
| **PRIVATE** | 個人文檔 | `INTERNAL` 或 `CONFIDENTIAL` | 個人筆記、私有文檔 |

---

## 📊 數據模型設計

### 1. FileAccessControl 模型

```python
class FileAccessControl(BaseModel):
    """文件訪問控制模型"""
    
    # 訪問級別（優先級從高到低）
    access_level: str = Field(
        ...,
        description="訪問級別: PUBLIC | ORGANIZATION | SECURITY_GROUP | PRIVATE"
    )
    
    # 組織級授權（access_level = ORGANIZATION）
    authorized_organizations: Optional[List[str]] = Field(
        None,
        description="授權組織ID列表（僅當 access_level=ORGANIZATION 時使用）"
    )
    
    # 安全組級授權（access_level = SECURITY_GROUP）
    authorized_security_groups: Optional[List[str]] = Field(
        None,
        description="授權安全組ID列表（僅當 access_level=SECURITY_GROUP 時使用）"
    )
    
    # 用戶級授權（access_level = PRIVATE）
    authorized_users: Optional[List[str]] = Field(
        None,
        description="授權用戶ID列表（僅當 access_level=PRIVATE 時使用，默認包含 owner）"
    )
    
    # 數據分類（AI治理要求）
    data_classification: Optional[str] = Field(
        default="internal",
        description="數據分類級別: public | internal | confidential | restricted"
    )
    
    # 敏感性標籤（AI治理要求）
    sensitivity_labels: Optional[List[str]] = Field(
        default_factory=list,
        description="敏感性標籤列表: PII, PHI, FINANCIAL, IP, CUSTOMER, PROPRIETARY"
    )
    
    # 所有者信息
    owner_id: str = Field(..., description="文件所有者用戶ID")
    owner_tenant_id: Optional[str] = Field(None, description="文件所有者租戶ID")
    
    # 審計字段
    access_log_enabled: bool = Field(
        default=True,
        description="是否啟用訪問日誌（AI治理要求）"
    )
    
    # 過期時間（可選）
    access_expires_at: Optional[datetime] = Field(
        None,
        description="訪問權限過期時間（可選，用於臨時授權）"
    )
```

### 2. 擴展 FileMetadata 模型

```python
class FileMetadata(FileMetadataBase):
    """擴展的文件元數據模型"""
    
    # ... 現有字段 ...
    
    # 訪問控制（新增）
    access_control: FileAccessControl = Field(
        ...,
        description="文件訪問控制配置"
    )
    
    # 數據分類（與 access_control 中的 data_classification 保持一致）
    data_classification: Optional[str] = Field(
        None,
        description="數據分類級別（與 access_control.data_classification 同步）"
    )
    
    # 敏感性標籤（與 access_control 中的 sensitivity_labels 保持一致）
    sensitivity_labels: Optional[List[str]] = Field(
        default_factory=list,
        description="敏感性標籤列表（與 access_control.sensitivity_labels 同步）"
    )
```

---

## 🔐 權限檢查邏輯

### 1. 核心檢查方法

```python
class FilePermissionService:
    """擴展的文件權限檢查服務"""
    
    def check_file_access_with_acl(
        self,
        user: User,
        file_metadata: FileMetadata,
        required_permission: str = Permission.FILE_READ.value,
    ) -> bool:
        """
        基於訪問控制列表（ACL）檢查文件訪問權限
        
        AI治理原則：
        1. 最小權限原則：默認拒絕，明確授權
        2. 數據分類檢查：用戶權限級別必須匹配或高於文件分類級別
        3. 分層授權：按優先級檢查（PUBLIC → ORGANIZATION → SECURITY_GROUP → PRIVATE）
        4. 審計日誌：記錄所有訪問嘗試
        
        Args:
            user: 當前用戶
            file_metadata: 文件元數據（包含 access_control）
            required_permission: 需要的權限
            
        Returns:
            bool: 是否有權限訪問
        """
        access_control = file_metadata.access_control
        
        # 1. 檢查訪問權限是否過期
        if access_control.access_expires_at:
            if datetime.utcnow() > access_control.access_expires_at:
                self._log_access_denied(
                    user, file_metadata, "Access expired",
                    required_permission
                )
                return False
        
        # 2. 數據分類級別檢查（AI治理要求）
        if not self._check_data_classification_access(
            user, access_control.data_classification
        ):
            self._log_access_denied(
                user, file_metadata, 
                f"Insufficient clearance for {access_control.data_classification}",
                required_permission
            )
            return False
        
        # 3. 敏感性標籤檢查（AI治理要求）
        if not self._check_sensitivity_labels_access(
            user, access_control.sensitivity_labels
        ):
            self._log_access_denied(
                user, file_metadata,
                f"User lacks required sensitivity label access",
                required_permission
            )
            return False
        
        # 4. 按訪問級別檢查權限（優先級從高到低）
        access_level = access_control.access_level
        
        # 4.1 PUBLIC：全公司可見
        if access_level == FileAccessLevel.PUBLIC:
            if user.has_permission(Permission.FILE_READ.value):
                self._log_access_granted(user, file_metadata, "PUBLIC access")
                return True
        
        # 4.2 ORGANIZATION：組織級授權
        elif access_level == FileAccessLevel.ORGANIZATION:
            user_org_id = self._get_user_organization_id(user)
            if user_org_id in (access_control.authorized_organizations or []):
                if user.has_permission(Permission.FILE_READ.value):
                    self._log_access_granted(user, file_metadata, "ORGANIZATION access")
                    return True
        
        # 4.3 SECURITY_GROUP：安全組級授權
        elif access_level == FileAccessLevel.SECURITY_GROUP:
            user_security_groups = self._get_user_security_groups(user)
            authorized_groups = access_control.authorized_security_groups or []
            if any(g in authorized_groups for g in user_security_groups):
                if user.has_permission(Permission.FILE_READ.value):
                    self._log_access_granted(user, file_metadata, "SECURITY_GROUP access")
                    return True
        
        # 4.4 PRIVATE：私有（默認）
        elif access_level == FileAccessLevel.PRIVATE:
            # 檢查用戶是否為文件所有者
            if file_metadata.user_id == user.user_id:
                self._log_access_granted(user, file_metadata, "OWNER access")
                return True
            
            # 檢查用戶是否在授權用戶列表中
            authorized_users = access_control.authorized_users or []
            if user.user_id in authorized_users:
                if user.has_permission(Permission.FILE_READ.value):
                    self._log_access_granted(user, file_metadata, "PRIVATE authorized access")
                    return True
        
        # 5. 默認拒絕（最小權限原則）
        self._log_access_denied(
            user, file_metadata, 
            f"Access level {access_level} check failed",
            required_permission
        )
        return False
```

### 2. 數據分類級別檢查

```python
def _check_data_classification_access(
    self,
    user: User,
    file_classification: str,
) -> bool:
    """
    檢查用戶是否有權限訪問指定分類級別的數據
    
    AI治理原則：用戶權限級別必須匹配或高於文件分類級別
    
    權限級別映射：
    - PUBLIC: 所有用戶可訪問
    - INTERNAL: 需要內部用戶權限
    - CONFIDENTIAL: 需要機密訪問權限
    - RESTRICTED: 需要限制訪問權限（最高級別）
    """
    # 超級管理員可以訪問所有級別
    if user.has_permission(Permission.ALL.value):
        return True
    
    # 權限級別映射
    classification_permissions = {
        DataClassification.PUBLIC.value: [],  # 無需特殊權限
        DataClassification.INTERNAL.value: ["data:access:internal"],
        DataClassification.CONFIDENTIAL.value: ["data:access:confidential"],
        DataClassification.RESTRICTED.value: ["data:access:restricted"],
    }
    
    required_permissions = classification_permissions.get(
        file_classification, 
        ["data:access:internal"]  # 默認需要內部權限
    )
    
    # 如果無需特殊權限，直接允許
    if not required_permissions:
        return True
    
    # 檢查用戶是否擁有所需權限
    return user.has_any_permission(*required_permissions)
```

### 3. 敏感性標籤檢查

```python
def _check_sensitivity_labels_access(
    self,
    user: User,
    file_sensitivity_labels: List[str],
) -> bool:
    """
    檢查用戶是否有權限訪問包含特定敏感性標籤的數據
    
    AI治理原則：用戶必須擁有對應敏感性標籤的訪問權限
    """
    if not file_sensitivity_labels:
        return True  # 無敏感性標籤，直接允許
    
    # 超級管理員可以訪問所有標籤
    if user.has_permission(Permission.ALL.value):
        return True
    
    # 檢查用戶是否擁有所有所需標籤的訪問權限
    for label in file_sensitivity_labels:
        required_permission = f"data:label:{label}"
        if not user.has_permission(required_permission):
            return False
    
    return True
```

---

## 🔍 向量和知識圖譜的訪問控制

### 1. 向量檢索時的權限過濾

```python
def query_vectors_with_acl(
    self,
    query_text: str,
    user: User,
    n_results: int = 10,
    **kwargs
) -> List[Dict[str, Any]]:
    """
    帶訪問控制權限檢查的向量檢索
    
    AI治理要求：
    1. 只返回用戶有權限訪問的文件向量
    2. 根據文件訪問級別過濾結果
    """
    # 1. 執行向量檢索
    results = self.query(query_text, n_results=n_results * 2, **kwargs)  # 多檢索一些，用於過濾
    
    # 2. 獲取文件元數據並檢查權限
    filtered_results = []
    permission_service = get_file_permission_service()
    
    for result in results:
        file_id = result.get("metadata", {}).get("file_id")
        if not file_id:
            continue
        
        # 獲取文件元數據
        file_metadata = self.metadata_service.get(file_id)
        if not file_metadata:
            continue
        
        # 檢查訪問權限
        if permission_service.check_file_access_with_acl(
            user=user,
            file_metadata=file_metadata,
            required_permission=Permission.FILE_READ.value,
        ):
            filtered_results.append(result)
            
            if len(filtered_results) >= n_results:
                break
    
    return filtered_results
```

### 2. 知識圖譜查詢時的權限過濾

```python
def query_kg_with_acl(
    self,
    query: str,
    user: User,
    **kwargs
) -> List[Dict[str, Any]]:
    """
    帶訪問控制權限檢查的知識圖譜查詢
    
    AI治理要求：
    1. 只返回用戶有權限訪問的文件知識圖譜數據
    2. 根據文件訪問級別過濾實體和關係
    """
    # 1. 執行知識圖譜查詢
    kg_results = self.query_kg(query, **kwargs)
    
    # 2. 獲取關聯的文件ID並檢查權限
    permission_service = get_file_permission_service()
    filtered_results = []
    
    for result in kg_results:
        file_id = result.get("file_id")
        if not file_id:
            continue
        
        # 獲取文件元數據
        file_metadata = self.metadata_service.get(file_id)
        if not file_metadata:
            continue
        
        # 檢查訪問權限
        if permission_service.check_file_access_with_acl(
            user=user,
            file_metadata=file_metadata,
            required_permission=Permission.FILE_READ.value,
        ):
            filtered_results.append(result)
    
    return filtered_results
```

---

## 📝 默認策略

### 文件上傳時的默認訪問控制配置

```python
def get_default_access_control(
    user: User,
    tenant_id: Optional[str] = None,
) -> FileAccessControl:
    """
    獲取默認的文件訪問控制配置
    
    AI治理原則：默認私有，最小權限
    """
    return FileAccessControl(
        access_level=FileAccessLevel.PRIVATE,  # 默認私有
        owner_id=user.user_id,
        owner_tenant_id=tenant_id,
        data_classification=DataClassification.INTERNAL.value,  # 默認內部
        sensitivity_labels=[],
        authorized_users=[user.user_id],  # 默認只有所有者
    )
```

---

## 🔐 權限枚舉擴展

### 建議的權限枚舉擴展

```python
# system/security/models.py

class Permission(str, Enum):
    # ... 現有權限 ...
    
    # 數據訪問權限（AI治理要求）
    DATA_ACCESS_INTERNAL = "data:access:internal"  # 內部數據訪問
    DATA_ACCESS_CONFIDENTIAL = "data:access:confidential"  # 機密數據訪問
    DATA_ACCESS_RESTRICTED = "data:access:restricted"  # 限制數據訪問
    
    # 敏感性標籤訪問權限
    DATA_LABEL_PII = "data:label:pii"  # PII 標籤訪問
    DATA_LABEL_PHI = "data:label:phi"  # PHI 標籤訪問
    DATA_LABEL_FINANCIAL = "data:label:financial"  # 財務標籤訪問
    DATA_LABEL_IP = "data:label:ip"  # IP 標籤訪問
    DATA_LABEL_CUSTOMER = "data:label:customer"  # 客戶標籤訪問
    DATA_LABEL_PROPRIETARY = "data:label:proprietary"  # 專有標籤訪問
```

---

## 📋 實施建議

### 階段一：基礎模型擴展（優先級：高）

1. 擴展 `FileMetadata` 模型，添加 `access_control` 字段
2. 創建 `FileAccessControl` 模型
3. 更新 `FileMetadataService` 支持訪問控制字段

### 階段二：權限檢查邏輯（優先級：高）

1. 擴展 `FilePermissionService`，實現 `check_file_access_with_acl`
2. 實現數據分類和敏感性標籤檢查
3. 實現組織和安全組查詢邏輯

### 階段三：向量和圖譜權限過濾（優先級：中）

1. 在向量檢索時添加權限過濾
2. 在知識圖譜查詢時添加權限過濾
3. 確保 RAG 檢索結果符合訪問控制

### 階段四：審計和合規（優先級：中）

1. 實現訪問日誌記錄
2. 實現訪問審計報告
3. 實現合規性檢查

---

## ✅ AI 治理合規性

### 合規性要求

1. **數據分類**：使用 `DataClassification` 枚舉
2. **敏感性標籤**：使用 `SensitivityLabel` 枚舉
3. **最小權限**：默認私有，按需授權
4. **訪問審計**：記錄所有訪問操作
5. **權限過期**：支持臨時授權

### 與現有系統集成

1. **多租戶**：通過 `tenant_id` 實現租戶隔離
2. **數據分類**：復用 `DataClassification` 和 `SensitivityLabel`
3. **權限模型**：擴展 `Permission` 枚舉，添加數據訪問權限
4. **審計日誌**：使用 `audit_logs` collection 記錄訪問

---

## 📚 相關文檔

- [上傳的功能架構說明-v3.0](./上傳的功能架構說明-v3.0.md) - 主架構文檔
- [文件授權管理實施計劃](./文件授權管理實施計劃.md) - 詳細的實施計劃和時間表
- [安全架構說明](../../安全架构说明.md) - 系統安全架構
- [數據分類模型](../../../services/api/models/data_classification.py) - 數據分類定義

---

**最後更新日期**: 2026-01-02

