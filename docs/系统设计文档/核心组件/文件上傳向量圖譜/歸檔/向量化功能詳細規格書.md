# 向量化功能詳細規格書

**文檔版本**: v1.0
**創建日期**: 2025-12-10
**創建人**: Daniel Chung
**最後修改日期**: 2025-12-10

---

## 目錄

1. [概述](#概述)
2. [系統架構](#系統架構)
3. [數據模型](#數據模型)
4. [組件架構](#組件架構)
5. [流程說明](#流程說明)
6. [後台代碼詳解](#後台代碼詳解)
7. [前台代碼詳解](#前台代碼詳解)
8. [API 接口規範](#api-接口規範)
9. [配置說明](#配置說明)
10. [錯誤處理](#錯誤處理)
11. [性能優化](#性能優化)

---

## 概述

### 功能描述

向量化功能是 AI-Box 系統的核心功能之一，負責將上傳的文件（文本、圖片等）轉換為向量表示，並存儲到向量數據庫（ChromaDB）中，以支持語義搜索、相似度匹配等 AI 應用場景。

### 核心能力

- **文件解析**: 支持多種文件格式（Markdown、PDF、圖片等）的解析
- **文本分塊**: 將長文本分割成適合向量化的塊（chunks）
- **向量生成**: 使用 Ollama 嵌入模型生成文本向量
- **向量存儲**: 將向量存儲到 ChromaDB 並建立索引
- **向量查詢**: 支持相似度搜索和統計信息查詢
- **統計分析**: 提供向量數量、維度、字符數等統計信息

### 技術棧

- **後端**: Python 3.9+, FastAPI, ChromaDB
- **前端**: React, TypeScript, Tailwind CSS
- **向量模型**: Ollama (mistral-nemo:12b, nomic-embed-text 等)
- **數據庫**: ChromaDB (HTTP 模式), ArangoDB (元數據)

---

## 系統架構

### 整體架構圖

\`\`\`mermaid
graph TB
    subgraph "前端層"
        A[React 前端] --> B[API 客戶端]
    end

    subgraph "API 層"
        B --> C[FastAPI Router]
        C --> D[文件管理 Router]
        C --> E[文件上傳 Router]
    end

    subgraph "服務層"
        D --> F[向量存儲服務]
        E --> G[嵌入服務]
        E --> H[文件解析服務]
        E --> I[分塊處理服務]
        F --> J[ChromaDB 客戶端]
        G --> K[Ollama API]
    end

    subgraph "數據層"
        J --> L[ChromaDB]
        F --> M[ArangoDB]
        E --> N[文件存儲]
    end

    style A fill:#e1f5ff
    style C fill:#fff4e1
    style F fill:#e8f5e9
    style G fill:#e8f5e9
    style L fill:#fce4ec
    style M fill:#fce4ec
\`\`\`

---

## 數據模型

### 向量數據模型

\`\`\`mermaid
erDiagram
    VECTOR ||--o{ CHUNK : contains
    CHUNK ||--|| EMBEDDING : has
    FILE ||--o{ VECTOR : generates
    USER ||--o{ FILE : owns

    VECTOR {
        string file_id PK
        string user_id FK
        string collection_name
        int vector_count
        int dimension
        int total_chars
        int avg_chars_per_chunk
        int total_words
        int avg_words_per_chunk
    }

    CHUNK {
        string id PK
        string file_id FK
        int chunk_index
        string text
        json metadata
        string document
    }

    EMBEDDING {
        string chunk_id FK
        float[] vector
        int dimension
    }

    FILE {
        string file_id PK
        string task_id
        string storage_path
        string file_type
        string user_id FK
    }

    USER {
        string user_id PK
        string email
    }
\`\`\`

### 向量存儲結構

\`\`\`mermaid
classDiagram
    class VectorStore {
        +string file_id
        +string user_id
        +string collection_name
        +List~Chunk~ chunks
        +List~Embedding~ embeddings
    }

    class Chunk {
        +string id
        +string file_id
        +int chunk_index
        +string text
        +dict metadata
        +string document
    }

    class Embedding {
        +string chunk_id
        +List~float~ vector
        +int dimension
    }

    class Metadata {
        +string file_id
        +string user_id
        +int chunk_index
        +int chunk_count
        +string task_id
        +string content_type
    }

    VectorStore "1" *-- "many" Chunk
    Chunk "1" -- "1" Embedding
    Chunk "1" -- "1" Metadata
\`\`\`

### ChromaDB Collection 結構

\`\`\`mermaid
graph LR
    A[Collection: file_{file_id}] --> B[Document: 文本內容]
    A --> C[Embedding: 向量數據]
    A --> D[Metadata: 元數據]
    A --> E[ID: {file_id}_chunk_{index}]

    D --> F[file_id]
    D --> G[user_id]
    D --> H[chunk_index]
    D --> I[chunk_count]
    D --> J[task_id]
    D --> K[content_type]
\`\`\`

---

## 組件架構

### 後台組件架構

\`\`\`mermaid
graph TB
    subgraph "API 路由層"
        A[file_management.py]
        B[file_upload.py]
    end

    subgraph "服務層"
        C[VectorStoreService]
        D[EmbeddingService]
        E[FileMetadataService]
        F[FilePermissionService]
    end

    subgraph "數據訪問層"
        G[ChromaDBClient]
        H[ArangoDB Client]
        I[FileStorage]
    end

    subgraph "外部服務"
        J[Ollama API]
        K[ChromaDB Server]
    end

    A --> C
    A --> E
    A --> F
    B --> C
    B --> D
    B --> E
    C --> G
    C --> H
    D --> J
    G --> K
    E --> H
    F --> H

    style C fill:#e8f5e9
    style D fill:#e8f5e9
    style G fill:#fff4e1
    style J fill:#fce4ec
\`\`\`

### 前台組件架構

\`\`\`mermaid
graph TB
    subgraph "頁面組件"
        A[FileManagement]
        B[Home]
    end

    subgraph "展示組件"
        C[MarkdownViewer]
        D[FilePreview]
        E[FileDataPreview]
    end

    subgraph "API 客戶端"
        F[api.ts]
    end

    subgraph "狀態管理"
        G[React State]
        H[Context API]
    end

    A --> C
    A --> D
    B --> E
    C --> F
    D --> F
    E --> F
    F --> G
    C --> H

    style C fill:#e1f5ff
    style D fill:#e1f5ff
    style F fill:#fff4e1
\`\`\`

### 組件依賴關係

\`\`\`mermaid
graph LR
    A[MarkdownViewer] --> B[getFileVectors]
    A --> C[getFileGraph]
    A --> D[regenerateFileData]
    B --> E[apiGet]
    C --> E
    D --> F[apiPost]
    E --> G[apiRequest]
    F --> G
    G --> H[FastAPI Backend]

    style A fill:#e1f5ff
    style H fill:#fff4e1
\`\`\`

---

## 流程說明

### 向量化完整流程

\`\`\`mermaid
sequenceDiagram
    participant User as 用戶
    participant Frontend as 前端
    participant API as API 路由
    participant Upload as 上傳服務
    participant Parser as 解析服務
    participant Chunker as 分塊服務
    participant Embedding as 嵌入服務
    participant VectorStore as 向量存儲服務
    participant ChromaDB as ChromaDB
    participant Ollama as Ollama API

    User->>Frontend: 上傳文件
    Frontend->>API: POST /files/upload
    API->>Upload: 保存文件
    Upload->>API: 返回 file_id
    API->>Frontend: 返回上傳成功

    API->>Upload: 觸發後台任務
    Upload->>Parser: 解析文件
    Parser->>Upload: 返回文本內容
    Upload->>Chunker: 分塊處理
    Chunker->>Upload: 返回 chunks

    Upload->>Embedding: 批量生成向量
    Embedding->>Ollama: POST /api/embeddings
    Ollama->>Embedding: 返回向量
    Embedding->>Upload: 返回 embeddings

    Upload->>VectorStore: 存儲向量
    VectorStore->>ChromaDB: 存儲到 Collection
    ChromaDB->>VectorStore: 確認存儲
    VectorStore->>Upload: 存儲成功

    Upload->>API: 更新處理狀態
    API->>Frontend: WebSocket/輪詢更新
\`\`\`

### 向量查詢流程

\`\`\`mermaid
sequenceDiagram
    participant User as 用戶
    participant Frontend as 前端
    participant API as API 路由
    participant VectorStore as 向量存儲服務
    participant ChromaDB as ChromaDB
    participant Embedding as 嵌入服務
    participant Ollama as Ollama API

    User->>Frontend: 查看向量數據
    Frontend->>API: GET /files/{file_id}/vectors
    API->>VectorStore: 查詢向量
    VectorStore->>ChromaDB: 查詢 Collection
    ChromaDB->>VectorStore: 返回向量數據
    VectorStore->>VectorStore: 計算統計信息
    VectorStore->>API: 返回向量和統計
    API->>Frontend: 返回 JSON 響應
    Frontend->>User: 顯示向量數據
\`\`\`

### 向量重新生成流程

\`\`\`mermaid
sequenceDiagram
    participant User as 用戶
    participant Frontend as 前端
    participant API as API 路由
    participant Background as 後台任務
    participant VectorStore as 向量存儲服務
    participant ChromaDB as ChromaDB

    User->>Frontend: 點擊重新生成
    Frontend->>API: POST /files/{file_id}/regenerate
    API->>API: 驗證權限
    API->>Background: 添加後台任務
    API->>Frontend: 返回處理中狀態

    Background->>Background: 解析文件
    Background->>Background: 分塊處理
    Background->>Background: 生成向量
    Background->>VectorStore: 存儲向量
    VectorStore->>ChromaDB: 更新 Collection
    ChromaDB->>VectorStore: 確認更新
    VectorStore->>Background: 存儲成功
    Background->>API: 更新處理狀態
\`\`\`

---

## 後台代碼詳解

### 1. 向量存儲服務 (VectorStoreService)

**文件路徑**: `services/api/services/vector_store_service.py`

#### 核心類

\`\`\`python
class VectorStoreService:
    """向量存儲服務類 - 封裝 ChromaDB 操作"""

    def __init__(self, client: Optional[ChromaDBClient] = None):
        """初始化向量存儲服務"""

    def get_or_create_collection(
        self, file_id: str, user_id: Optional[str] = None
    ) -> ChromaCollection:
        """獲取或創建 Collection"""

    def store_vectors(
        self,
        file_id: str,
        chunks: List[Dict[str, Any]],
        embeddings: List[List[float]],
        user_id: Optional[str] = None,
    ) -> bool:
        """存儲向量到 ChromaDB"""

    def get_vectors_by_file_id(
        self,
        file_id: str,
        user_id: Optional[str] = None,
        limit: Optional[int] = None,
        offset: int = 0,
    ) -> List[Dict[str, Any]]:
        """根據文件 ID 查詢向量"""

    def get_collection_stats(
        self, file_id: str, user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """獲取 Collection 統計信息"""

    def query_vectors(
        self,
        query_text: Optional[str] = None,
        query_embedding: Optional[List[float]] = None,
        file_id: Optional[str] = None,
        user_id: Optional[str] = None,
        n_results: int = 10,
    ) -> List[Dict[str, Any]]:
        """查詢相似向量"""
\`\`\`

#### 關鍵方法說明

**store_vectors**: 存儲向量數據

- 輸入: \`file_id\`, \`chunks\`, \`embeddings\`, \`user_id\`
- 處理:
  1. 創建或獲取 Collection
  2. 準備 IDs、documents、metadatas
  3. 批量存儲到 ChromaDB
- 輸出: \`bool\` (成功/失敗)

**get_collection_stats**: 獲取統計信息

- 返回字段:
  - \`vector_count\`: 向量數量
  - \`dimension\`: 向量維度
  - \`total_chars\`: 總字符數
  - \`avg_chars_per_chunk\`: 平均字符數/塊
  - \`total_words\`: 總詞數
  - \`avg_words_per_chunk\`: 平均詞數/塊
  - \`collection_name\`: 集合名稱

### 2. 嵌入服務 (EmbeddingService)

**文件路徑**: `services/api/services/embedding_service.py`

#### 核心類

\`\`\`python
class EmbeddingService:
    """向量化服務類 - 使用 Ollama 生成 embeddings"""

    def __init__(
        self,
        ollama_url: Optional[str] = None,
        model: Optional[str] = None,
        batch_size: int = 10,
        max_retries: int = 3,
        timeout: float = 60.0,
    ):
        """初始化向量化服務"""

    async def generate_embedding(
        self,
        text: str,
        user_id: Optional[str] = None,
        file_id: Optional[str] = None,
        task_id: Optional[str] = None,
    ) -> List[float]:
        """生成單個文本的嵌入向量"""

    async def generate_embeddings_batch(
        self, texts: List[str]
    ) -> List[List[float]]:
        """批量生成嵌入向量"""

    async def is_available(self) -> bool:
        """檢查 Ollama 服務是否可用"""
\`\`\`

#### 配置來源

1. **配置文件**: \`config/config.json\`
   \`\`\`json
   {
     "embedding": {
       "ollama_url": "<http://localhost:11434>",
       "model": "mistral-nemo:12b"
     }
   }
   \`\`\`

2. **環境變量**: \`OLLAMA_URL\`, \`OLLAMA_EMBEDDING_MODEL\`

3. **默認值**: \`<http://localhost:11434\`>, \`nomic-embed-text\`

### 3. 文件上傳路由 (file_upload.py)

**文件路徑**: `api/routers/file_upload.py`

#### 核心函數

\`\`\`python
async def process_vectorization_only(
    file_id: str,
    file_path: str,
    file_type: Optional[str],
    user_id: str,
) -> None:
    """異步處理文件向量化（只執行分塊+向量化+存儲）"""
\`\`\`

#### 處理流程

1. **文件解析** (0-50%)
   - 獲取文件解析器
   - 解析文件內容
   - 更新處理狀態

2. **文本分塊** (50%)
   - 獲取分塊處理器
   - 處理文本分塊
   - 更新處理狀態

3. **向量生成** (50-90%)
   - 批量生成向量
   - 更新處理狀態

4. **向量存儲** (90-100%)
   - 存儲到 ChromaDB
   - 更新處理狀態
   - 完成處理

### 4. 文件管理路由 (file_management.py)

**文件路徑**: `api/routers/file_management.py`

#### 核心端點

**GET /files/{file_id}/vectors**

- 功能: 查詢文件的向量數據
- 參數: \`limit\`, \`offset\`
- 返回: 向量列表和統計信息

**POST /files/{file_id}/regenerate**

- 功能: 重新生成文件的向量數據
- 參數: \`type: "vector" | "graph"\`
- 返回: 處理狀態

---

## 前台代碼詳解

### 1. MarkdownViewer 組件

**文件路徑**: `ai-bot/src/components/MarkdownViewer.tsx`

#### 核心功能

\`\`\`typescript
interface MarkdownViewerProps {
  content: string;
  fileId?: string;
  mode?: PreviewMode; // 'text' | 'vector' | 'graph'
}

const MarkdownViewer: React.FC<MarkdownViewerProps> = ({
  content,
  fileId,
  mode = 'text'
}) => {
  // 狀態管理
  const [vectorData, setVectorData] = useState<VectorData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 數據加載
  const loadDataForMode = async (targetMode: PreviewMode) => {
    if (targetMode === 'vector') {
      const response = await getFileVectors(fileId, 100, 0);
      if (response.success && response.data) {
        setVectorData(response.data);
      }
    }
  };

  // 模式切換
  const handleModeChange = (newMode: PreviewMode) => {
    setMode(newMode);
    if (newMode !== 'text') {
      loadDataForMode(newMode);
    }
  };

  // 渲染向量數據
  return (
    <div>
      {/_模式切換按鈕 _/}
      {/_ 向量統計信息 _/}
      {/_ 向量列表_/}
    </div>
  );
};
\`\`\`

#### 向量數據顯示

**統計信息卡片**:

- 向量數量
- 向量維度
- 集合名稱
- 總字符數
- 平均字符數/塊
- 總詞數
- 平均詞數/塊

**向量列表**:

- 向量 ID
- 元數據 (JSON 格式)
- 文檔內容
- 向量維度

### 2. API 客戶端 (api.ts)

**文件路徑**: `ai-bot/src/lib/api.ts`

#### 核心函數

\`\`\`typescript
/**

- 獲取文件的向量資料
 */
export async function getFileVectors(
  fileId: string,
  limit: number = 100,
  offset: number = 0
): Promise<{ success: boolean; data?: any; message?: string }> {
  return apiGet(\`/files/\${fileId}/vectors?limit=\${limit}&offset=\${offset}\`);
}

/**

- 重新生成文件的向量或圖譜數據
 */
export async function regenerateFileData(
  fileId: string,
  type: 'vector' | 'graph'
): Promise<{ success: boolean; data?: any; message?: string }> {
  return apiPost(\`/files/\${fileId}/regenerate\`, { type });
}
\`\`\`

---

## API 接口規範

### 1. 獲取向量數據

**端點**: \`GET /api/v1/files/{file_id}/vectors\`

**請求參數**:

- \`file_id\` (path): 文件 ID
- \`limit\` (query): 返回數量限制 (1-1000, 默認 100)
- \`offset\` (query): 偏移量 (默認 0)

**響應格式**:
\`\`\`json
{
  "success": true,
  "data": {
    "vectors": [
      {
        "id": "file_id_chunk_0",
        "document": "文本內容",
        "metadata": {
          "file_id": "file_id",
          "chunk_index": 0,
          "chunk_count": 3,
          "user_id": "user@example.com"
        },
        "embedding": [0.1, 0.2, ...]
      }
    ],
    "stats": {
      "vector_count": 3,
      "dimension": 5120,
      "collection_name": "file_file_id",
      "total_chars": 2479,
      "avg_chars_per_chunk": 826,
      "total_words": 402,
      "avg_words_per_chunk": 134
    },
    "total": 3
  },
  "message": "查詢成功"
}
\`\`\`

### 2. 重新生成向量

**端點**: \`POST /api/v1/files/{file_id}/regenerate\`

**請求體**:
\`\`\`json
{
  "type": "vector"
}
\`\`\`

**響應格式**:
\`\`\`json
{
  "success": true,
  "data": {
    "file_id": "file_id",
    "type": "vector",
    "status": "processing"
  },
  "message": "向量重新生成已啟動，處理將在後台進行"
}
\`\`\`

---

## 配置說明

### 1. ChromaDB 配置

**文件**: \`config/config.json\`

\`\`\`json
{
  "datastores": {
    "chromadb": {
      "mode": "http",
      "host": "localhost",
      "port": 8001,
      "mount_path": "/Users/daniel/GitHub/AI-Box/data/datasets/chromadb"
    }
  }
}
\`\`\`

### 2. Embedding 配置

**文件**: \`config/config.json\`

\`\`\`json
{
  "embedding": {
    "ollama_url": "<http://localhost:11434>",
    "model": "mistral-nemo:12b",
    "batch_size": 10,
    "max_retries": 3,
    "timeout": 60.0
  }
}
\`\`\`

### 3. 環境變量

\`\`\`bash

# ChromaDB

CHROMADB_MODE=http
CHROMADB_HOST=localhost
CHROMADB_PORT=8001
CHROMADB_PERSIST_DIR=/path/to/chromadb

# Ollama

OLLAMA_URL=<http://localhost:11434>
OLLAMA_EMBEDDING_MODEL=mistral-nemo:12b
\`\`\`

---

## 錯誤處理

### 錯誤類型

1. **文件不存在**: \`404 Not Found\`
2. **權限不足**: \`403 Forbidden\`
3. **向量生成失敗**: \`500 Internal Server Error\`
4. **ChromaDB 連接失敗**: \`500 Internal Server Error\`
5. **Ollama 服務不可用**: \`503 Service Unavailable\`

### 錯誤處理流程

\`\`\`mermaid
graph TD
    A[請求] --> B{驗證權限}
    B -->|失敗| C[返回 403]
    B -->|成功| D{檢查文件}
    D -->|不存在| E[返回 404]
    D -->|存在| F{執行操作}
    F -->|成功| G[返回 200]
    F -->|失敗| H{錯誤類型}
    H -->|網絡錯誤| I[重試 3 次]
    H -->|服務錯誤| J[返回 500]
    H -->|配置錯誤| K[返回 400]
    I -->|成功| G
    I -->|失敗| J
\`\`\`

---

## 性能優化

### 1. 批量處理

- **向量生成**: 使用 \`generate_embeddings_batch\` 批量處理
- **批量大小**: 默認 10，可根據 Ollama 性能調整
- **並發控制**: 使用 \`asyncio.Semaphore\` 限制並發數

### 2. 緩存策略

- **Collection 緩存**: 在服務實例中緩存 Collection 對象
- **統計信息緩存**: 對於大集合（>1000），統計信息計算有性能限制

### 3. 異步處理

- **後台任務**: 向量化處理使用 FastAPI BackgroundTasks
- **非阻塞**: API 立即返回，處理在後台進行
- **狀態更新**: 通過 Redis 更新處理狀態

### 4. 數據庫優化

- **索引**: ChromaDB 自動為向量建立索引
- **分頁**: 查詢支持 limit/offset 分頁
- **過濾**: 支持按 file_id、user_id 過濾

---

## 附錄

### A. 文件結構

\`\`\`
AI-Box/
├── api/
│   └── routers/
│       ├── file_management.py    # 文件管理路由
│       └── file_upload.py        # 文件上傳路由
├── services/
│   └── api/
│       └── services/
│           ├── vector_store_service.py  # 向量存儲服務
│           └── embedding_service.py    # 嵌入服務
├── database/
│   └── chromadb.py               # ChromaDB 客戶端
├── ai-bot/
│   └── src/
│       ├── components/
│       │   ├── MarkdownViewer.tsx      # Markdown 查看器
│       │   ├── FilePreview.tsx          # 文件預覽
│       │   └── FileDataPreview.tsx     # 文件數據預覽
│       └── lib/
│           └── api.ts                   # API 客戶端
└── config/
    └── config.json                      # 配置文件
\`\`\`

### B. 關鍵依賴

**後端**:

- \`chromadb\`: ChromaDB 客戶端
- \`httpx\`: HTTP 客戶端（用於 Ollama API）
- \`fastapi\`: Web 框架
- \`structlog\`: 結構化日誌

**前端**:

- \`react\`: UI 框架
- \`typescript\`: 類型系統
- \`tailwindcss\`: CSS 框架

### C. 日誌規範

所有服務使用 \`structlog\` 進行結構化日誌記錄：

\`\`\`python
logger.info(
    "Stored vectors successfully",
    file_id=file_id,
    vector_count=len(embeddings),
    collection_name=collection.name,
)
\`\`\`

---

**文檔結束**
