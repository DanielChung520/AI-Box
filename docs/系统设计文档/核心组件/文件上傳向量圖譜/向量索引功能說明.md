# 向量索引功能說明

**創建日期**: 2026-01-05
**創建人**: Daniel Chung
**最後修改日期**: 2026-01-21

---

## 📋 概述

本文檔說明 AI-Box 系統中向量索引的功能和實現方式。

**重要更新** (2026-01-20):

- ✅ 向量數據庫從 ChromaDB 遷移到 **Qdrant**
- ✅ 實現**雙軌 RAG 解析架構**（Stage 1 快速軌 + Stage 2 深度軌）

---

## 🔍 向量索引是什麼？

向量索引是將文檔內容轉換為向量（embedding）並存儲在向量數據庫（**Qdrant**）中的過程。向量索引允許系統根據語義相似度進行文檔檢索，而不是基於關鍵詞匹配。

---

## 🏗️ 系統架構

### 1. 向量存儲層（Qdrant）

**位置**: `services/api/services/qdrant_vector_store_service.py`

**功能**:

- 管理 Qdrant 連接
- 提供向量存儲和查詢接口
- 支持按文件 ID 組織集合（`file_based` 命名策略）

**集合命名策略**:

- 每個文件對應一個 Qdrant 集合
- 集合名稱 = `file_{file_id}`
- 例如: 文件 ID `f347352c-a30e-4598-b0e8-60811b949751` 對應集合 `file_f347352c-a30e-4598-b0e8-60811b949751`

**Qdrant 優勢**:

- ✅ 更好的性能（相比 ChromaDB）
- ✅ 內建 Dashboard（<http://localhost:6333/dashboard）>
- ✅ 支持 gRPC 和 REST API
- ✅ 更好的可擴展性

### 2. 向量適配器層（QdrantAdapter）

**位置**: `services/api/services/qdrant_vector_store_service.py`

**功能**:

- 封裝 Qdrant 操作
- 提供統一的存儲接口
- 處理文檔分塊和向量化

**關鍵方法**:

- `store_vectors()`: 存儲向量到 Qdrant
- `query_vectors()`: 查詢相似向量
- `get_collection_stats()`: 獲取集合統計信息

### 3. 檢索服務層（RealtimeRetrievalService）

**位置**: `agents/infra/memory/aam/realtime_retrieval.py`

**功能**:

- 執行向量檢索
- 管理檢索緩存
- 提供統一的檢索接口

**關鍵方法**:

- `retrieve()`: 執行向量檢索，返回相關文檔

---

## 📝 向量化流程（雙軌 RAG 架構）

### 1. 文件上傳

當文件上傳到系統時：

1. 文件存儲到文件系統（SeaweedFS）
2. 文件元數據存儲到 ArangoDB (`file_metadata` 集合)
3. 文件狀態標記為 `uploaded`

### 2. 文件處理（雙軌架構）

文件處理流程採用**雙軌並行解析架構**（由 Worker 執行）：

#### Stage 1: 快速軌（基礎索引）

**目標**: 快速完成基礎向量索引，提供即時檢索能力

**流程**:

1. **分塊（Chunking）**: 將文檔分割成小塊（使用語義分塊或 AST 驅動策略）
2. **快速向量化（Fast Vectorization）**:
   - 使用 Embedding 模型（`bge-m3` / `qwen3-embedding`）將文本塊轉換為向量
   - 立即存儲到 Qdrant 對應的集合中（基礎 Payload）
3. **立即可用**: 完成後立即提供檢索能力

**時間**: 30-60 秒

#### Stage 2: 深度軌（背景任務）

**目標**: 使用 LLM + VLM 進行深度理解，生成摘要和 Contextual Header

**流程**（在背景任務中執行）:

1. **Prompt A（語意摘要員）**: 生成全局背景摘要
2. **Prompt B（視覺解析員）**: 圖片和表格轉文字
3. **Prompt C（整合封裝員）**: 為每個 chunk 生成 Contextual Header
4. **更新 Payload**: 使用 Qdrant `upsert` 更新 Payload（添加 `global_summary`, `contextual_header` 等）

**時間**: 30-60 秒（背景處理，不影響 Stage 1 的檢索功能）

### 3. 向量索引構建

向量索引在向量化階段自動構建：

- Qdrant 自動為向量創建索引（HNSW 索引）
- 無需手動構建索引
- 索引隨向量數據的添加自動更新

**詳細說明**: 請參閱 [AI-Box 雙軌 RAG 解析規格書](./AI-Box雙軌RAG解析規格書.md)

---

## 🔧 向量索引的查詢流程

### 1. HybridRAG 檢索

當執行 HybridRAG 檢索時：

1. **向量檢索（Vector Retrieval）**:
   - 使用 `QdrantVectorStoreService` 查詢 Qdrant
   - 根據查詢文本生成 embedding
   - 使用相似度搜索找到相關文檔塊
   - **雙軌優勢**: Stage 2 的 Contextual Header 提供更多上下文，提升檢索相關性

2. **圖檢索（Graph Retrieval）**:
   - 使用 NER 提取實體
   - 在 ArangoDB 中查找匹配的實體
   - 獲取實體的鄰居節點和子圖

3. **結果合併（Merge）**:
   - 合併向量和圖檢索結果
   - 應用權重（向量 70%，圖 30%）
   - 按相關度排序

### 2. 查詢示例

```python
# 1. 初始化服務
aam_manager = AAMManager(
    chromadb_adapter=chromadb_adapter,
    ...
)

# 2. 執行檢索
retrieval_service = RealtimeRetrievalService(aam_manager)
results = retrieval_service.retrieve(
    query="請說明中国预制菜产业市场规模与增长趋势",
    limit=10,
    min_relevance=0.0
)

# 3. 結果包含：
# - content: 文檔內容
# - relevance_score: 相關度分數
# - metadata: 元數據（source, file_id 等）
```

---

## ⚠️ 常見問題

### Q1: 為什麼查詢返回 0 個結果？

**可能原因**:

1. 文件尚未完成向量化處理（Stage 1 未完成）
2. Qdrant 集合存在但無向量數據
3. 查詢與文檔內容的語義相似度較低

**檢查方法**:

```python
# 檢查文件處理狀態
from database.arangodb.client import ArangoDBClient

client = ArangoDBClient()
if client.db:
    # 檢查文件元數據
    aql = """
        FOR doc IN file_metadata
            FILTER doc.filename LIKE '%預製菜%'
            RETURN doc
    """
    files = list(client.db.aql.execute(aql))

    # 檢查處理狀態
    if client.db.has_collection('processing_status'):
        aql_status = """
            FOR doc IN processing_status
                FILTER doc.file_id == @file_id
                RETURN doc
        """
        status = list(client.db.aql.execute(aql_status, bind_vars={"file_id": file_id}))
```

### Q2: 如何確認向量索引已構建？

**方法 1**: 檢查 Qdrant 集合

```python
from services.api.services.qdrant_vector_store_service import get_qdrant_vector_store_service

vector_store_service = get_qdrant_vector_store_service()
stats = vector_store_service.get_collection_stats(
    file_id=file_id,
    user_id=user_id
)
if stats and stats.get("vector_count", 0) > 0:
    print(f"集合 {stats['collection_name']} 包含 {stats['vector_count']} 個向量")
```

**方法 2**: 使用 Qdrant Dashboard

- 訪問 <http://localhost:6333/dashboard>
- 查看集合列表和向量數量

**方法 3**: 檢查處理狀態

```python
# 檢查 processing_status 集合
# vectorization.status 應該為 "completed"
# vectorization.progress 應該為 100
```

### Q3: 向量索引是否需要手動構建？

**不需要**。Qdrant 會自動為向量創建索引（HNSW 索引），無需手動構建。索引隨向量數據的添加自動更新。

### Q4: Stage 1 和 Stage 2 的區別是什麼？

- **Stage 1（快速軌）**: 快速完成基礎向量索引，立即提供檢索能力（30-60秒）
- **Stage 2（深度軌）**: 背景任務，生成摘要和 Contextual Header，提升檢索精度（30-60秒，不影響檢索）

**詳細說明**: 請參閱 [AI-Box 雙軌 RAG 解析規格書](./AI-Box雙軌RAG解析規格書.md)

---

## 📊 數據流程圖（雙軌 RAG 架構）

```
文件上傳
  ↓
文件存儲（SeaweedFS）
  ↓
文件元數據存儲（ArangoDB）
  ↓
文件處理（Worker）
  ↓
├─ Stage 1: 快速軌（基礎索引）
│   ├─ 分塊（Chunking）
│   ├─ 快速向量化（Embedding）
│   └─ 存儲到 Qdrant（基礎 Payload）
│       └─ ✅ 立即提供檢索能力
│
├─ Stage 2: 深度軌（背景任務）
│   ├─ Prompt A: 語意摘要員（生成全局摘要）
│   ├─ Prompt B: 視覺解析員（圖片/表格轉文字）
│   ├─ Prompt C: 整合封裝員（生成 Contextual Header）
│   └─ 更新 Qdrant Payload（upsert）
│       └─ ✅ 提升檢索精度
│
└─ 知識圖譜提取（KG Extraction）
    ↓
   存儲到 ArangoDB（entities, relations）
```

---

## 🔗 相關文檔

- [AI-Box 雙軌 RAG 解析規格書](./AI-Box雙軌RAG解析規格書.md) - 雙軌架構詳細說明
- [AI-Box 雙軌 RAG 解析實施計劃書](./AI-Box雙軌RAG解析實施計劃書.md) - 實施計劃和進度管控
- [上傳的功能架構說明-v4.0.md](./上傳的功能架構說明-v4.0.md) - 完整上傳架構
- [VectorDB.md](./VectorDB.md) - Qdrant 向量數據庫架構
- [向量與圖檢索混合查詢邏輯.md](./向量與圖檢索混合查詢邏輯.md) - HybridRAG 檢索邏輯

---

**最後更新日期**: 2026-01-21
**維護人**: Daniel Chung
