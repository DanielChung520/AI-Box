# 向量與圖檢索混合查詢邏輯

**創建日期**: 2026-01-05
**創建人**: Daniel Chung
**最後修改日期**: 2026-01-21

---

## 📋 概述

本文檔詳細說明基於 `HybridRAGService._graph_retrieval()` 方法的向量與圖檢索混合查詢邏輯，描述如何結合向量檢索（**Qdrant**）和圖譜檢索（ArangoDB）實現 Hybrid RAG（混合檢索增強生成）系統。

**重要更新** (2026-01-20):

- ✅ 向量數據庫從 ChromaDB 遷移到 **Qdrant**
- ✅ 雙軌 RAG 架構的 Contextual Header 提升檢索相關性

### 核心設計理念

**問題**：傳統的向量檢索只能找到語義相似的文檔片段，無法利用知識圖譜中的邏輯關係進行推理檢索。

**解決方案**：

1. **向量檢索**：快速找到語義相似的文檔片段（**Qdrant**）
2. **圖譜檢索**：通過知識圖譜的邏輯關係進行推理檢索（ArangoDB）
3. **混合檢索**：結合兩種檢索結果，提供更全面的知識檢索能力
4. **雙軌 RAG 增強**：Stage 2 的 Contextual Header 提供更多上下文，提升檢索精度

### 設計目標

- ✅ **全面性**：結合向量檢索的語義匹配和圖譜檢索的邏輯推理
- ✅ **性能**：支持並行檢索，提高檢索效率
- ✅ **靈活性**：支持多種檢索策略（向量優先、圖優先、混合模式）
- ✅ **可擴展性**：易於擴展新的檢索策略和結果融合方法

---

## 📊 實現狀態總覽

本文檔描述的功能架構與實際代碼實現的對比分析，幫助讀者了解系統的實際狀態和待改進點。

### 功能實現狀態總覽

| 功能模塊 | 實現狀態 | 完成度 | 備註 |
|---------|---------|--------|------|
| **HybridRAGService 框架** | ✅ 已實現 | 100% | 支持三種檢索策略，結果融合機制已實現 |
| **_graph_retrieval() 方法** | ✅ 已實現 | 100% | 完整實現實體識別、匹配、圖遍歷和結果格式化 |
| **結果融合機制** | ✅ 已實現 | 100% | 去重、加權合併、排序已實現 |
| **RetrievalManager 整合** | ✅ 已實現 | 100% | 已支持 HybridRAGService 作為可選策略 |
| **ChatMemoryService 整合** | ✗ 未實現 | 0% | 當前只使用向量檢索，未整合 HybridRAGService |
| **基礎設施（NER/KG服務）** | ✅ 已具備 | 100% | NER 服務、圖譜查詢服務和工具函數已可用 |

### 核心功能實現詳情

#### ✅ 已完全實現的功能

##### 1. HybridRAGService 框架

**實現位置**: `genai/workflows/rag/hybrid_rag.py`

**實現狀態**:

- ✅ 類定義完整（第 32-246 行）
- ✅ 支持三種檢索策略（VECTOR_FIRST, GRAPH_FIRST, HYBRID）
- ✅ 向量優先檢索（`_vector_first_retrieval`）已實現
- ✅ 圖優先檢索（`_graph_first_retrieval`）框架已實現
- ✅ 混合檢索（`_hybrid_retrieval`）已實現，支持並行執行
- ✅ 結果融合機制（`_merge_results`）已實現
- ✅ 結果格式化（`_format_for_llm`）已實現

**依賴服務**:

- ✅ `AAMManager`：AAM 管理器（已實現）
- ✅ `RealtimeRetrievalService`：實時檢索服務，用於向量檢索（已實現）
- ✅ `QdrantVectorStoreService`：Qdrant 向量存儲服務（已實現）
- ⚠️ **注意**：當前實現依賴 AAM 系統，AAM 系統底層使用 Qdrant 進行向量存儲

##### 2. 結果融合機制

**實現位置**: `genai/workflows/rag/hybrid_rag.py` 第 178-210 行

**實現狀態**:

- ✅ 去重機制（基於 `memory_id`）
- ✅ 加權合併（`vector_weight`, `graph_weight`）
- ✅ 排序機制（按 `relevance_score` 降序）
- ✅ 支持同一結果在兩種檢索中出現時的融合

##### 3. RetrievalManager 整合

**實現位置**: `genai/workflows/rag/manager.py` 第 82-90 行

**實現狀態**:

- ✅ 已支持 HybridRAGService 作為可選策略
- ✅ 如果提供了 `aam_hybrid_rag` 參數，優先使用 HybridRAGService
- ✅ 如果 HybridRAGService 失敗，降級到標準檢索邏輯

#### ✗ 未實現的功能

##### 1. _graph_retrieval() 方法

**實現位置**: `genai/workflows/rag/hybrid_rag.py` 第 176-240 行

**實現狀態**: ✅ **已實現**（2026-01-05）

**實現說明**:
該方法已完整實現，包括實體識別、實體匹配、圖遍歷和結果格式化四個步驟。

**已使用的基礎設施**:

- ✅ `NERService.extract_entities()` - 實體識別服務（`genai/api/services/ner_service.py`）
- ✅ `KGBuilderService.get_entity_neighbors()` - 獲取鄰居節點（`kg_builder_service.py` 第 712-723 行）
- ✅ `KGBuilderService.get_entity_subgraph()` - 獲取子圖（`kg_builder_service.py` 第 725-732 行）
- ✅ AQL 查詢 - 實體匹配查詢（使用 ArangoDB AQL 進行名稱模糊匹配）

**實現的功能**:

1. ✅ 實體識別：使用 NER 服務從查詢中提取實體（`_extract_entities_from_query()`）
2. ✅ 實體匹配：在 ArangoDB 中查找匹配的實體（`_find_matching_entities()`）
3. ✅ 圖遍歷：獲取實體的鄰居節點和子圖（使用 `KGBuilderService`）
4. ✅ 結果格式化：將圖譜數據轉換為 Memory 格式（`_format_graph_results()`）

**輔助方法**:

- `_get_ner_service()` - 獲取 NER 服務實例（懶加載）
- `_get_kg_service()` - 獲取圖譜構建服務實例（懶加載）
- `_extract_entities_from_query(query)` - 從查詢中提取實體（第 251-282 行）
- `_find_matching_entities(entities, limit)` - 在 ArangoDB 中查找匹配的實體（第 284-346 行）
- `_format_graph_results(graph_results, query, limit)` - 將圖譜數據轉換為 Memory 格式（第 351-463 行）

##### 2. ChatMemoryService 整合

**實現位置**: `services/api/services/chat_memory_service.py` 第 158-420 行

**當前實現**:

- ✅ 只使用向量檢索（`query_vectors` 或 `query_vectors_with_acl`）
- ✅ 支持 AAM 長期記憶檢索
- ✗ 未使用 HybridRAGService

**改進計劃**:

- 未來可以整合 HybridRAGService 以支持圖譜檢索
- 需要考慮如何與現有的向量檢索和 AAM 記憶整合

### 實現差異點總結

#### 1. 功能完整性差異

| 功能 | 文檔描述 | 實際實現 | 差異 |
|------|---------|---------|------|
| HybridRAGService 框架 | 完整設計 | ✅ 完全實現 | 無差異 |
| 檢索策略 | 三種策略 | ✅ 完全實現 | 無差異 |
| 結果融合 | 完整設計 | ✅ 完全實現 | 無差異 |
| 圖檢索 | 詳細設計 | ✗ 未實現 | 設計與實現不一致 |
| RetrievalManager 整合 | 已設計 | ✅ 已實現 | 無差異 |
| ChatMemoryService 整合 | 已設計 | ✗ 未實現 | 設計與實現不一致 |

#### 2. 技術實現差異

**向量檢索實現**:

- **文檔**: 描述使用 Qdrant 進行向量檢索
- **實現**: 實際使用 AAM 系統的 `RealtimeRetrievalService`，底層使用 Qdrant
- **差異**: 實現依賴 AAM 系統，AAM 系統底層使用 Qdrant 進行向量存儲

**圖檢索實現**:

- **文檔**: [向量與圖檢索混合查詢邏輯](./向量與圖檢索混合查詢邏輯.md) 提供完整實現設計
- **實現**: `_graph_retrieval()` 方法僅有框架，返回空列表
- **差異**: 設計完整但未實現，相關基礎設施已具備

### 建議改進優先級

#### 高優先級（影響核心功能）

1. **實現 _graph_retrieval() 方法**
   - 基礎設施已具備，只需整合實現
   - 參考：本文檔的「圖譜檢索實現設計」章節
   - 預計工作量：1-2 週

#### 中優先級（功能增強）

2. **ChatMemoryService 整合**
   - 整合 HybridRAGService 到 ChatMemoryService
   - 考慮如何與現有的向量檢索和 AAM 記憶整合
   - 預計工作量：1-2 週

---

## 🏗️ 架構設計

### 核心組件

```mermaid
graph TD
    subgraph HybridRAG["Hybrid RAG Service"]
        HRS[HybridRAGService混合檢索服務]
        VS[Vector Retrieval向量檢索]
        GR[Graph Retrieval圖譜檢索]
        MR[Merge Results結果融合]
    end

    subgraph VectorStore["向量存儲"]
        Qdrant[(Qdrant向量數據庫)]
    end

    subgraph GraphStore["圖譜存儲"]
        ArangoDB[(ArangoDB圖數據庫)]
        Entities[實體集合]
        Relations[關係集合]
    end

    subgraph SupportServices["支持服務"]
        NER[NER Service實體識別]
        KGB[KGBuilderService圖譜構建服務]
    end

    HRS --> VS
    HRS --> GR
    VS --> Qdrant
    VS --> MR
    GR --> ArangoDB
    GR --> NER
    GR --> KGB
    GR --> MR
    ArangoDB --> Entities
    ArangoDB --> Relations
    MR --> Results[檢索結果]

    classDef hybrid fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef vector fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef graphStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef support fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px

    class HRS,VS,GR,MR hybrid
    class Qdrant vector
    class ArangoDB,Entities,Relations graphStyle
    class NER,KGB support
```

---

## 🔄 檢索流程

### 完整檢索流程（Sequence Diagram）

```mermaid
sequenceDiagram
    participant User as 用戶查詢
    participant HRS as HybridRAGService
    participant Strategy as 檢索策略
    participant VR as 向量檢索
    participant GR as 圖譜檢索
    participant NER as NER服務
    participant KG as KGBuilderService
    participant ArangoDB as ArangoDB
    participant Qdrant as Qdrant
    participant MR as 結果融合
    participant Result as 檢索結果

    User->>HRS: retrieve(query, top_k, strategy)

    alt 策略 == VECTOR_FIRST
        HRS->>VR: 執行向量檢索
        VR->>Qdrant: query_vectors(query, top_k)
        Qdrant-->>VR: 向量檢索結果
        VR-->>HRS: vector_results

        alt 結果不足
            HRS->>GR: 圖譜檢索補充
            Note over GR,ArangoDB: 圖譜檢索流程
            GR-->>HRS: graph_results
            HRS->>MR: 合併結果(vector_results + graph_results)
        else 結果充足
            HRS->>Result: 返回 vector_results
        end
    else 策略 == GRAPH_FIRST
        HRS->>GR: 執行圖譜檢索
        Note over GR,ArangoDB: 圖譜檢索流程
        GR-->>HRS: graph_results

        alt 結果不足
            HRS->>VR: 向量檢索補充
            VR->>Qdrant: query_vectors(query, top_k)
            Qdrant-->>VR: 向量檢索結果
            VR-->>HRS: vector_results
            HRS->>MR: 合併結果(graph_results + vector_results)
        else 結果充足
            HRS->>Result: 返回 graph_results
        end
    else 策略 == HYBRID
        par 並行執行
            HRS->>VR: 向量檢索任務
            VR->>Qdrant: query_vectors(query, top_k*2)
            Qdrant-->>VR: 向量檢索結果
            VR-->>HRS: vector_results
        and
            HRS->>GR: 圖譜檢索任務
            Note over GR,ArangoDB: 圖譜檢索流程
            GR-->>HRS: graph_results
        end
        HRS->>MR: 融合結果(vector_results, graph_results)
    end

    MR->>MR: 去重（基於 memory_id）
    MR->>MR: 加權合併（vector_weight, graph_weight）
    MR->>MR: 按相關度排序
    MR-->>HRS: merged_results
    HRS->>Result: 格式化結果
    Result-->>User: 檢索結果列表
```

### 圖譜檢索詳細流程（Sequence Diagram）

```mermaid
sequenceDiagram
    participant GR as _graph_retrieval
    participant NER as NER Service
    participant KGB as KGBuilderService
    participant ArangoDB as ArangoDB
    participant Filter as filter_entities
    participant Neighbors as fetch_neighbors
    participant Subgraph as fetch_subgraph
    participant Format as 結果格式化

    GR->>NER: extract_entities(query)
    NER-->>GR: entities: List[Entity]

    loop 每個實體
        GR->>KGB: list_entities(filters)
        KGB->>ArangoDB: 查詢匹配的實體
        Note over ArangoDB: AQL: FILTER doc.name == @entity_name<br/>OR doc.name LIKE @entity_name
        ArangoDB-->>KGB: matched_entities

        alt 找到匹配實體
            loop 每個匹配實體
                GR->>KGB: get_entity_neighbors(entity_id, limit)
                KGB->>Neighbors: fetch_neighbors(client, entity_id)
                Neighbors->>ArangoDB: 圖遍歷查詢（1度關係）
                Note over ArangoDB: AQL: FOR v, e IN 1..1 ANY<br/>@start_vertex @@edge_collection
                ArangoDB-->>Neighbors: neighbors: List[Dict]
                Neighbors-->>KGB: neighbors
                KGB-->>GR: neighbors

                GR->>KGB: get_entity_subgraph(entity_id, max_depth=2)
                KGB->>Subgraph: fetch_subgraph(client, entity_id, max_depth=2)
                Subgraph->>ArangoDB: 圖遍歷查詢（N度關係）
                Note over ArangoDB: AQL: FOR v, e, p IN 1..@max_depth ANY<br/>@start_vertex @@edge_collection
                ArangoDB-->>Subgraph: subgraph: List[Dict]
                Subgraph-->>KGB: subgraph
                KGB-->>GR: subgraph
            end
        end
    end

    GR->>Format: 將圖譜數據轉換為 Memory 格式
    Format->>Format: 提取實體和關係信息
    Format->>Format: 構建文本內容（實體-關係-實體）
    Format->>Format: 計算相關度分數
    Format-->>GR: memories: List[Memory]
    GR-->>GR: 返回 memories
```

---

## 🔧 核心組件詳解

### 1. HybridRAGService

**位置**: `genai/workflows/rag/hybrid_rag.py`

**實現狀態**: ✅ **已實現**（框架完整，`_graph_retrieval()` 方法已實現）

**依賴服務**:

- `AAMManager`：AAM 管理器（用於長期記憶管理）
- `RealtimeRetrievalService`：實時檢索服務（用於向量檢索）
- ⚠️ **注意**：當前實現依賴 AAM 系統，不是直接使用 Qdrant。向量檢索通過 `RealtimeRetrievalService` 進行，該服務內部使用 Qdrant 進行向量存儲。

**核心方法**:

#### `retrieve(query, top_k, strategy, min_relevance)`

執行混合 RAG 檢索，根據策略調用對應的檢索方法。

**實現狀態**: ✅ **已實現**

**參數**:

- `query`: 查詢文本
- `top_k`: 返回結果數量
- `strategy`: 檢索策略（VECTOR_FIRST, GRAPH_FIRST, HYBRID）
- `min_relevance`: 最小相關度閾值

**返回**: `List[Dict[str, Any]]` - 格式化後的檢索結果

**實現位置**: `genai/workflows/rag/hybrid_rag.py` 第 66-112 行

#### `_graph_retrieval(query, limit)`

圖譜檢索核心方法。

**實現狀態**: ✅ **已實現**（2026-01-05）

**實現位置**: `genai/workflows/rag/hybrid_rag.py` 第 176-237 行

**實現說明**:

該方法已完整實現，包括以下步驟：

1. ✅ **實體識別**：使用 `_extract_entities_from_query()` 從查詢中提取實體
2. ✅ **實體匹配**：使用 `_find_matching_entities()` 在 ArangoDB 中查找匹配的實體
3. ✅ **圖遍歷**：使用 `KGBuilderService.get_entity_neighbors()` 和 `get_entity_subgraph()` 獲取實體的鄰居節點和子圖
4. ✅ **結果格式化**：使用 `_format_graph_results()` 將圖譜數據轉換為 Memory 格式

**已使用的基礎設施**:

- ✅ `NERService.extract_entities()` - 實體識別服務
- ✅ `KGBuilderService.get_entity_neighbors()` - 獲取鄰居節點
- ✅ `KGBuilderService.get_entity_subgraph()` - 獲取子圖
- ✅ AQL 查詢 - 實體匹配查詢（使用 ArangoDB AQL 進行名稱模糊匹配）

**輔助方法**:

- `_get_ner_service()` - 獲取 NER 服務實例（懶加載）
- `_get_kg_service()` - 獲取圖譜構建服務實例（懶加載）
- `_extract_entities_from_query(query)` - 從查詢中提取實體
- `_find_matching_entities(entities, limit)` - 在 ArangoDB 中查找匹配的實體
- `_format_graph_results(graph_results, query, limit)` - 將圖譜數據轉換為 Memory 格式

詳細說明見「圖譜檢索實現設計」章節。

### 2. 檢索策略

#### VECTOR_FIRST（向量優先）

1. 先執行向量檢索
2. 如果結果不足，使用圖譜檢索補充
3. 適用場景：需要快速響應、查詢語義明確

#### GRAPH_FIRST（圖優先）

1. 先執行圖譜檢索
2. 如果結果不足，使用向量檢索補充
3. 適用場景：需要邏輯推理、查詢包含明確實體

#### HYBRID（混合模式）

1. 並行執行向量檢索和圖譜檢索
2. 融合結果（加權合併、去重、排序）
3. 適用場景：需要最全面的檢索結果

### 3. 結果融合策略

#### 去重機制

- 基於 `memory_id` 去重
- 優先保留向量檢索結果（相關度通常更高）

#### 加權合併

- `vector_weight`: 向量檢索權重（默認 0.6）
- `graph_weight`: 圖譜檢索權重（默認 0.4）
- 如果同一結果同時出現在兩種檢索中，增加相關度分數

#### 排序機制

- 按 `relevance_score` 降序排序
- 返回前 `top_k` 個結果

---

## 📝 圖譜檢索實現設計

### 實現狀態

**當前狀態**: ✅ **已實現**

**實現位置**: `genai/workflows/rag/hybrid_rag.py` 第 176-240 行

**實現日期**: 2026-01-05

**已具備的基礎設施**: ✅ **已具備**

實現 `_graph_retrieval()` 方法所需的所有基礎設施都已具備：

- **NER 服務**: `NERService.extract_entities()` - 實體識別服務（`genai/api/services/ner_service.py`）
- **圖譜查詢服務**:
  - `KGBuilderService.list_entities()` - 實體查詢服務（`genai/api/services/kg_builder_service.py` 第 686-711 行）
  - `KGBuilderService.get_entity_neighbors()` - 獲取鄰居節點（`kg_builder_service.py` 第 712-723 行）
  - `KGBuilderService.get_entity_subgraph()` - 獲取子圖（`kg_builder_service.py` 第 725-732 行）
- **圖譜查詢工具函數**:
  - `fetch_neighbors()` - 圖查詢工具函數（`database/arangodb/queries.py` 第 25-62 行）
  - `fetch_subgraph()` - 子圖查詢工具函數（`database/arangodb/queries.py` 第 65-103 行）

### _graph_retrieval() 實現方案（已實現）

**實現位置**: `genai/workflows/rag/hybrid_rag.py` 第 176-240 行

**實現說明**: 該方法已完整實現，包括以下步驟：

1. **實體識別**：使用 `_extract_entities_from_query()` 從查詢中提取實體
2. **實體匹配**：使用 `_find_matching_entities()` 在 ArangoDB 中查找匹配的實體
3. **圖遍歷**：使用 `KGBuilderService.get_entity_neighbors()` 和 `get_entity_subgraph()` 獲取實體的鄰居節點和子圖
4. **結果格式化**：使用 `_format_graph_results()` 將圖譜數據轉換為 Memory 格式

**實現細節**:

- **懶加載服務**：使用 `_get_ner_service()` 和 `_get_kg_service()` 實現服務的懶加載
- **異步處理**：`_extract_entities_from_query()` 處理 NER 服務的異步調用，支持事件循環檢測
- **實體匹配**：使用 AQL 查詢進行名稱模糊匹配（精確匹配、LIKE 匹配、CONTAINS 匹配）
- **結果去重**：基於三元組唯一標識進行去重
- **相關度計算**：根據實體匹配度計算相關度分數（0.6-0.9）

**輔助方法**:

- `_get_ner_service()` - 獲取 NER 服務實例（懶加載）
- `_get_kg_service()` - 獲取圖譜構建服務實例（懶加載）
- `_extract_entities_from_query(query)` - 從查詢中提取實體（第 251-282 行）
- `_find_matching_entities(entities, limit)` - 在 ArangoDB 中查找匹配的實體（第 284-346 行）
- `_format_graph_results(graph_results, query, limit)` - 將圖譜數據轉換為 Memory 格式（第 351-463 行）

### 關鍵步驟詳解

#### 步驟 1: 實體識別

**服務**: `NERService`

**方法**: `extract_entities(text, ontology_rules)`

**功能**:

- 從查詢文本中提取命名實體
- 支持 Ontology 約束（實體類型列表）
- 返回 `List[Entity]`

**實現位置**: `genai/api/services/ner_service.py`

#### 步驟 2: 實體匹配

**服務**: `KGBuilderService`

**方法**: `list_entities(filters)`

**功能**:

- 在 ArangoDB 中查找匹配的實體
- 支持名稱模糊匹配（LIKE 查詢）
- 支持實體類型過濾

**AQL 查詢示例**:

```aql
FOR doc IN entities
    FILTER doc.name == @entity_name
       OR doc.name LIKE CONCAT("%", @entity_name, "%")
    LIMIT @limit
    RETURN doc
```

#### 步驟 3: 圖遍歷

**工具函數**: `database/arangodb/queries.py`

**方法**:

- `fetch_neighbors()`: 獲取 1 度關係鄰居
- `fetch_subgraph()`: 獲取 N 度關係子圖

**AQL 查詢示例**:

```aql
# 鄰居節點
FOR v, e IN 1..1 ANY @start_vertex @@edge_collection
    LIMIT @limit
    RETURN {vertex: v, edge: e}

# 子圖
FOR v, e, p IN 1..@max_depth ANY @start_vertex @@edge_collection
    LIMIT @limit
    RETURN {path: p, vertex: v, edge: e}
```

#### 步驟 4: 結果格式化

**功能**:

- 將圖譜數據（實體和關係）轉換為 `Memory` 格式
- 構建文本內容（實體-關係-實體三元組文本）
- 計算相關度分數（基於實體匹配度和關係重要性）

**格式示例**:

```python
Memory(
    content="中央廚房 - 生產 - 預製菜產品",
    metadata={
        "source": "graph",
        "entity_id": "entity_123",
        "relation_type": "produces",
        "file_id": "file_456"
    },
    relevance_score=0.85
)
```

---

## 🎯 使用場景

### 場景 1: 簡單查詢（向量優先）

**查詢**: "如何生產預製菜？"

**流程**:

1. 向量檢索找到相關文檔片段
2. 如果結果不足，圖譜檢索補充相關實體和關係

**適用策略**: `VECTOR_FIRST`

### 場景 2: 實體查詢（圖優先）

**查詢**: "東方伊廚公司生產哪些產品？"

**流程**:

1. 識別實體："東方伊廚"（Organization）
2. 圖譜檢索找到該實體的關係和相關實體
3. 如果結果不足，向量檢索補充

**適用策略**: `GRAPH_FIRST`

### 場景 3: 複雜查詢（混合模式）

**查詢**: "預製菜產品的生產流程和質量標準"

**流程**:

1. 並行執行向量檢索和圖譜檢索
2. 向量檢索找到相關文檔片段
3. 圖譜檢索找到相關實體（預製菜、生產流程、質量標準）和關係
4. 融合兩種檢索結果

**適用策略**: `HYBRID`

---

## 📊 性能優化

### 並行檢索

**實現**: 使用 `ThreadPoolExecutor` 並行執行向量和圖檢索

**優勢**:

- 減少總檢索時間
- 提高系統吞吐量

**配置**:

- `max_workers`: 並行工作線程數（默認 4）

### 結果緩存

**實現**: 使用 `_cache` 字典緩存檢索結果

**緩存鍵**: `f"{query}:{top_k}:{strategy}"`

**優勢**:

- 避免重複檢索
- 提高響應速度

**注意**: 需要實現緩存過期機制

### 圖查詢優化

**索引**: 確保 ArangoDB 中的實體和關係有適當的索引

**建議索引**:

- `entities.name`: 全文索引或普通索引
- `entities.type`: 普通索引
- `relations.type`: 普通索引
- `relations._from`, `relations._to`: 邊索引（自動創建）

---

## 🔄 與現有系統的整合

### RetrievalManager 整合

**實現狀態**: ✅ **已實現**

**位置**: `genai/workflows/rag/manager.py`

**實現位置**: 第 82-90 行

**整合方式**:

- ✅ 在 `RetrievalManager` 中已支持 `HybridRAGService`
- ✅ 作為可選的檢索策略
- ✅ 如果提供了 `aam_hybrid_rag` 參數，優先使用 HybridRAGService
- ✅ 如果 HybridRAGService 失敗，降級到標準檢索邏輯

**當前實現**:

```python
# 當前實現（已支持）
if self.aam_hybrid_rag is not None and AAM_AVAILABLE:
    try:
        aam_results = self.aam_hybrid_rag.retrieve(query, top_k=n_results)
        if aam_results:
            logger.debug(f"AAM Hybrid RAG returned {len(aam_results)} results")
            return aam_results
    except Exception as e:
        logger.warning(f"AAM Hybrid RAG failed, falling back to standard retrieval: {e}")

# 標準檢索邏輯（fallback）
# ...
```

**使用方式**:

```python
# 初始化 RetrievalManager 時提供 HybridRAGService
hybrid_rag = HybridRAGService(aam_manager, ...)
retrieval_manager = RetrievalManager(
    aam_hybrid_rag=hybrid_rag  # 可選參數，使用 AAM 系統（底層使用 Qdrant）
)

# 檢索時會自動使用 HybridRAGService
results = retrieval_manager.retrieve(query, n_results=10)
```

### ChatMemoryService 整合

**實現狀態**: ✗ **未整合**

**位置**: `services/api/services/chat_memory_service.py`

**方法**: `retrieve_for_prompt()`

**實現位置**: 第 158-420 行

**當前實現**:

- ✅ 只使用向量檢索（`query_vectors` 或 `query_vectors_with_acl`）
- ✅ 支持 AAM 長期記憶檢索
- ✗ 未使用 HybridRAGService
- ✗ 不支持圖譜檢索

**當前實現示例**:

```python
# 當前實現（僅向量檢索）
embedding = await self._embedding_service.generate_embedding(normalized_query, ...)

# 向量檢索
rag_results = await asyncio.to_thread(
    self._vector_store_service.query_vectors_with_acl,
    user=user,
    query_embedding=embedding,
    file_id=fid,
    user_id=user_id,
    n_results=self._rag_top_k,
)

# AAM 長期記憶檢索
aam_results = await self._aam_manager.retrieve(...)
```

**改進計劃**:

未來可以整合 `HybridRAGService` 以支持圖譜檢索：

```python
# 未來實現（混合檢索）
# 1. 初始化 HybridRAGService（需要 AAMManager）
hybrid_rag = HybridRAGService(
    aam_manager=self._aam_manager,
    retrieval_service=RealtimeRetrievalService(self._aam_manager),
    strategy=RetrievalStrategy.HYBRID
)

# 2. 在 retrieve_for_prompt() 中使用
hybrid_results = hybrid_rag.retrieve(
    query=normalized_query,
    top_k=self._rag_top_k,
    strategy=RetrievalStrategy.HYBRID
)

# 3. 與 AAM 長期記憶合併
# ...
```

**整合考慮**:

- 需要考慮如何與現有的向量檢索和 AAM 記憶整合
- 需要處理權限檢查（ACL）與圖檢索的整合
- 需要考慮性能影響（圖檢索可能比向量檢索慢）

---

## 📚 相關文檔

### 核心架構文檔

- [強化 RAG 系統](./强化RAG系统.md) - RAG 系統架構詳解
- [知識圖譜系統](./知识图谱系统.md) - 知識圖譜系統架構詳解
- [上傳的功能架構說明](./上傳的功能架構說明-v3.0.md) - 文件上傳和處理流程

### 技術實現文檔

- `HybridRAGService`: `genai/workflows/rag/hybrid_rag.py` - 混合 RAG 服務實現
- `KGBuilderService`: `genai/api/services/kg_builder_service.py` - 圖譜構建服務
- `NERService`: `genai/api/services/ner_service.py` - 實體識別服務
- 圖譜查詢工具: `database/arangodb/queries.py` - 圖譜查詢工具函數
- `RetrievalManager`: `genai/workflows/rag/manager.py` - 檢索管理器（已支持 HybridRAGService）
- `ChatMemoryService`: `services/api/services/chat_memory_service.py` - 聊天記憶服務（未整合 HybridRAGService）
- `RealtimeRetrievalService`: `agents/infra/memory/aam/realtime_retrieval.py` - 實時檢索服務（向量檢索）

---

## 🔮 未來改進方向

### 短期改進（1-2 週）

#### 1. 實現 _graph_retrieval() 方法（已完成）

**狀態**: ✅ **已完成**（2026-01-05）

**實現內容**:

- ✅ 整合 NER 服務和圖譜查詢工具
- ✅ 實現實體識別和匹配邏輯
- ✅ 實現圖遍歷邏輯（鄰居節點和子圖）
- ✅ 實現結果格式化邏輯（將圖譜數據轉換為 Memory 格式）

**待完成任務**:

- ⏸️ 添加單元測試和集成測試（建議優先級：中）

**相關文檔**: 本文檔的「圖譜檢索實現設計」章節

#### 2. 結果融合優化（中優先級）

**目標**: 改進相關度分數計算方法

**任務**:

- 改進相關度分數計算方法
- 支持自適應權重調整
- 優化去重邏輯

**預計工作量**: 3-5 天

#### 3. ChatMemoryService 整合（中優先級）

**目標**: 整合 HybridRAGService 到 ChatMemoryService

**任務**:

- 在 ChatMemoryService 中整合 HybridRAGService
- 考慮如何與現有的向量檢索和 AAM 記憶整合
- 處理權限檢查（ACL）與圖檢索的整合
- 優化性能（考慮圖檢索的延遲）

**預計工作量**: 1-2 週

### 中期改進（1-2 個月）

1. **圖譜檢索優化**

   - 支持更複雜的圖查詢模式（路徑查詢、模式匹配）
   - 實現圖譜索引優化
2. **緩存機制**

   - 實現結果緩存
   - 支持緩存過期和更新策略

### 長期改進（3-6 個月）

1. **智能策略選擇**

   - 根據查詢類型自動選擇檢索策略
   - 使用機器學習優化權重參數
2. **圖譜推理增強**

   - 支持更複雜的圖推理模式
   - 實現知識圖譜嵌入（Knowledge Graph Embedding）

---

## 📊 實現狀態對比表

### 設計與實際實現對比

| 功能模塊 | 設計狀態 | 實際實現狀態 | 完成度 | 備註 |
|---------|---------|------------|--------|------|
| **HybridRAGService 框架** | 已設計 | ✅ 已實現 | 100% | 支持三種檢索策略，結果融合機制已實現 |
| **_graph_retrieval() 方法** | 已設計 | ✅ 已實現 | 100% | 完整實現實體識別、匹配、圖遍歷和結果格式化 |
| **結果融合機制** | 已設計 | ✅ 已實現 | 100% | 去重、加權合併、排序已實現 |
| **RetrievalManager 整合** | 已設計 | ✅ 已實現 | 100% | 已支持 HybridRAGService 作為可選策略 |
| **ChatMemoryService 整合** | 已設計 | ✗ 未實現 | 0% | 當前只使用向量檢索，未整合 HybridRAGService |
| **基礎設施（NER/KG服務）** | 已設計 | ✅ 已具備 | 100% | NER 服務、圖譜查詢服務和工具函數已可用 |

### 技術實現差異

#### 向量檢索實現差異

| 方面 | 文檔描述 | 實際實現 | 差異 |
|------|---------|---------|------|
| **數據庫** | Qdrant | AAM 系統（RealtimeRetrievalService，底層使用 Qdrant） | 實現依賴 AAM 系統，而非直接訪問 Qdrant |
| **檢索方式** | 直接查詢 Qdrant | 通過 RealtimeRetrievalService | 抽象層不同 |

#### 圖檢索實現差異

| 方面 | 文檔描述 | 實際實現 | 差異 |
|------|---------|---------|------|
| **實現狀態** | 完整設計方案 | 僅有框架，返回空列表 | 設計完整但未實現 |
| **基礎設施** | 需要 NER/KG 服務 | ✅ 已具備 | 基礎設施已準備就緒 |

---

## 更新記錄

- **2026-01-05**: 初始版本，描述基於 `HybridRAGService._graph_retrieval()` 的向量與圖檢索混合查詢邏輯
- **2026-01-05**: 添加實現狀態總覽章節，說明 HybridRAGService 框架已實現、_graph_retrieval() 未實現、以及依賴服務狀態；更新核心組件詳解，說明實際依賴（AAM 系統）；更新與現有系統的整合狀態，說明 RetrievalManager 已支持、ChatMemoryService 未整合；更新圖譜檢索實現設計，標註實現狀態和已具備的基礎設施；更新未來改進方向，調整優先級並添加 ChatMemoryService 整合計劃
- **2026-01-05**: 實現 `_graph_retrieval()` 方法，包括實體識別、實體匹配、圖遍歷和結果格式化；添加輔助方法 `_extract_entities_from_query()`, `_find_matching_entities()`, `_format_graph_results()`, `_get_ner_service()`, `_get_kg_service()`；更新實現狀態為「已實現」
