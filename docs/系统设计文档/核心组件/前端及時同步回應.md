# 前端及時同步回應機制

**版本**: v1.0.0
**創建日期**: 2026-02-09
**適用範圍**: NLP 前端、MM-Agent
**狀態**: 正式版

---

## 1. 概述

本文檔描述前端 NLP 頁面如何即時同步顯示 Agent 的思考過程和任務計劃，採用 WebSocket/SSE 雙通道傳輸機制。

### 1.1 設計目標

| 目標 | 說明 |
|------|------|
| **及時性** | 思考過程即時顯示，不等待完整回覆 |
| **分段顯示** | 思考過程和任務計劃分段渲染 |
| **格式化** | Markdown 格式正確顯示（粗體、列表、標題） |
| **狀態管理** | 用戶回覆「是」時能繼續執行工作流 |

### 1.2 通信架構

```
┌─────────────────┐         ┌─────────────────┐
│   前端 NLP      │  WebSocket   │  MM-Agent      │
│   (8503)       │ ◄─────────► │  (8003)        │
│                 │    SSE       │                 │
└─────────────────┘             └─────────────────┘
       │                               │
       │  Markdown 渲染                │ LLM 生成
       ▼                               ▼
┌─────────────────────────────────────────────────┐
│  思考過程 (Thinking)  →  任務計劃 (Plan)  →  Ready │
└─────────────────────────────────────────────────┘
```

---

## 2. WebSocket 事件類型

### 2.1 事件定義

| 事件類型 | 說明 | 數據結構 |
|----------|------|----------|
| `workflow_started` | 工作流開始 | `{type, message, session_id}` |
| `thinking` | 思考過程片段 | `{type, content, session_id}` |
| `thinking_complete` | 思考過程完成 | `{type, message, session_id}` |
| `plan_started` | 任務計劃開始 | `{type, message, session_id}` |
| `plan` | 任務計劃步驟 | `{type, content, session_id}` |
| `ready` | 準備就緒 | `{type, message, session_id}` |
| `complete` | 完成 | `{type, message, session_id}` |
| `error` | 錯誤 | `{type, message, session_id}` |

### 2.2 數據流程

```
用戶輸入
    │
    ▼
┌─────────────────────┐
│  workflow_started   │  → 顯示客戶要求
└─────────────────────┘
    │
    ▼
┌─────────────────────┐
│      thinking       │  → 即時顯示思考過程
│      thinking       │
│      thinking       │
└─────────────────────┘
    │
    ▼
┌─────────────────────┐
│ thinking_complete   │  → 思考完成
└─────────────────────┘
    │
    ▼
┌─────────────────────┐
│      plan_started   │  → 計劃開始
└─────────────────────┘
    │
    ▼
┌─────────────────────┐
│        plan        │  → 顯示步驟 (Step 1, Step 2...)
│        plan        │
└─────────────────────┘
    │
    ▼
┌─────────────────────┐
│        ready        │  → 等待用戶確認
└─────────────────────┘
    │
    用戶回覆「是」
    │
    ▼
┌─────────────────────┐
│ CONTINUE_WORKFLOW   │  → 繼續執行工作流
└─────────────────────┘
```

---

## 3. 前端實現

### 3.1 WebSocket 連接

```typescript
// NLP.tsx
const connectWebSocket = (sid: string, instruction: string) => {
  const ws = new WebSocket(`${MM_AGENT_API.replace('http', 'ws')}/api/v1/chat/ws`);

  ws.onopen = () => {
    ws.send(JSON.stringify({ session_id: sid, instruction }));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    handleMessage(data);
  };

  return ws;
};
```

### 3.2 消息處理

```typescript
const handleMessage = (data: WebSocketMessage) => {
  switch (data.type) {
    case 'workflow_started':
      thinkingContentRef.current = `#### 思考過程\n\n${data.message}\n`;
      addChatMessage({ role: 'assistant', content: thinkingContentRef.current });
      break;

    case 'thinking':
      thinkingContentRef.current += data.content;
      updateChatMessage(assistantMsgIdRef.current, {
        content: `#### 思考過程\n\n${thinkingContentRef.current}`
      });
      break;

    case 'thinking_complete':
      planContentRef.current = '';
      break;

    case 'plan_started':
      planContentRef.current = '';
      break;

    case 'plan':
      planContentRef.current += data.content + '\n';
      updateChatMessage(assistantMsgIdRef.current, {
        content: formatFinalContent()
      });
      break;

    case 'ready':
      updateChatMessage(assistantMsgIdRef.current, {
        content: formatFinalContent()
      });
      setCurrentStatus('waiting_confirmation');
      break;

    case 'complete':
      setLoading(false);
      setCurrentStatus('completed');
      break;
  }
};
```

### 3.3 內容格式化

```typescript
const formatFinalContent = () => {
  return `#### 思考過程\n\n${thinkingContentRef.current.trim()}\n\n---\n\n## 任務計劃\n\n${planContentRef.current.trim()}\n\n是否開始執行？（回复「是」繼續，「否」取消）`;
};
```

### 3.4 Markdown 渲染

```typescript
<Markdown
  components={{
    h1: ({ children }) => <h1 style={{ fontSize: '1.5em', margin: '0.8em 0' }}>{children}</h1>,
    h2: ({ children }) => <h2 style={{ fontSize: '1.3em', margin: '0.7em 0', color: '#ff4d4f' }}>{children}</h2>,
    h3: ({ children }) => <h3 style={{ fontSize: '1.1em', margin: '0.6em 0', color: '#ff4d4f' }}>{children}</h3>,
    h4: ({ children }) => (
      <h4 style={{ fontSize: '1em', margin: '0.5em 0', color: '#1890ff', fontWeight: 'bold', fontStyle: 'italic' }}>
        {children}
      </h4>
    ),
    ul: ({ children }) => <ul style={{ paddingLeft: '1.5em', margin: '0.8em 0', lineHeight: '1.8' }}>{children}</ul>,
    ol: ({ children }) => <ol style={{ paddingLeft: '1.5em', margin: '0.8em 0', lineHeight: '1.8' }}>{children}</ol>,
    strong: ({ children }) => (
      <strong style={{ fontWeight: 'bold', color: '#000000' }}>{children}</strong>
    ),
    code: ({ inline, className, children }) => {
      if (inline) {
        return <code style={{ backgroundColor: '#f5f5f5', padding: '2px 6px', borderRadius: 4 }}>{children}</code>;
      }
      return <pre style={{ backgroundColor: '#f5f5f5', padding: '10px', borderRadius: 4 }}>{children}</pre>;
    },
  }}
>
  {message.content}
</Markdown>
```

---

## 4. 後端實現

### 4.1 WebSocket 端點

```python
# websocket_endpoint.py
async def websocket_generate_stream(websocket):
    """WebSocket 串流生成器"""

    # 接收用戶指令
    data = await websocket.receive_text()
    request_data = json.loads(data)
    instruction = request_data.get("instruction", "")
    session_id = request_data.get("session_id", f"ws-{id(websocket)}")

    # 調用 LLM 生成思考過程和計劃
    text, error = await loop.run_in_executor(
        executor,
        sync_ollama_stream,
        model_name,
        instruction,
        timeout
    )

    # 狀態機解析
    in_thinking = False
    in_plan = False
    thinking_content = ""
    plan_content = ""

    for line in text.strip().split('\n'):
        # 解析 <thinking>...</thinking> 和 <plan>...</plan>
        ...

    # 發送思考過程
    for chunk in thinking_content.split('\n'):
        await websocket.send_json({
            "type": "thinking",
            "content": chunk,
            "session_id": session_id
        })

    # 發送任務計劃
    for line in plan_content.strip().split('\n'):
        await websocket.send_json({
            "type": "plan",
            "content": line,
            "session_id": session_id
        })

    # 發送 ready
    await websocket.send_json({
        "type": "ready",
        "message": "yes",
        "session_id": session_id
    })

    # 存儲待執行工作流
    PENDING_WORKFLOWS[session_id] = {
        "instruction": instruction,
        "plan": plan_content,
        "thinking": thinking_content,
    }
```

### 4.2 Prompt 模板

```python
STREAM_PROMPT = """你是一位專業的庫存管理 AI Agent。

用戶指令：{instruction}

請嚴格按照以下格式輸出，每個步驟必須換行：

<thinking>
你的思考過程（用完整段落描述）
</thinking>

<plan>
Step 1: [動作] 描述（第一步驟）
Step 2: [動作] 描述（第二步驟）
Step 3: [動作] 描述（第三步驟）
...
</plan>

<ready>
yes
</ready>

重要：每個 Step 必須獨立一行，換行輸出。"""
```

---

## 5. 工作流繼續機制

### 5.1 流程說明

```
Step 1: 用戶輸入「ABC庫存分類」
        ↓
Step 2: 後端生成計劃，存儲到 PENDING_WORKFLOWS
        ↓
Step 3: 前端顯示「是否開始執行？（回复「是」繼續...」
        ↓
Step 4: 用戶回覆「是」
        ↓
Step 5: 前端發送 /api/v1/chat/intent
        {
          "instruction": "是",
          "session_id": "session-123"
        }
        ↓
Step 6: 後端檢查 PENDING_WORKFLOWS[session_id]
        ↓
Step 7: 啟動工作流，執行第一步
        ↓
Step 8: 返回 CONTINUE_WORKFLOW 意圖
```

### 5.2 意圖分類端點

```python
@app.post("/api/v1/chat/intent")
async def classify_intent(request: ChatRequest) -> dict:
    instruction = request.instruction
    session_id = request.session_id

    # 檢查 PENDING_WORKFLOWS
    if session_id in PENDING_WORKFLOWS:
        pending = PENDING_WORKFLOWS.pop(session_id)

        # 啟動工作流
        wf_result = await _react_engine.start_workflow(
            instruction=pending["instruction"],
            session_id=session_id,
            context={"original_plan": pending.get("plan")}
        )

        return {
            "success": True,
            "intent": "CONTINUE_WORKFLOW",
            "confidence": 1.0,
            "workflow_result": wf_result,
            ...
        }

    # 新對話，進行意圖分類
    result = await llm_classify_intent(instruction, session_id)
    return result
```

---

## 6. UI 樣式規範

### 6.1 思考過程樣式

```css
.thinking-process {
  color: #1890ff;
  font-weight: bold;
  font-style: italic;
  margin: 0.5em 0;
}
```

### 6.2 任務計劃樣式

```css
.task-plan {
  color: #000000;
  font-weight: bold;
  background-color: transparent;
}

.step-title {
  font-weight: bold;
}
```

### 6.3 澄清內容樣式

```css
.clarification {
  color: #ff4d4f;
  background-color: #fff2f0;
  border: 1px solid #ffa39e;
  border-radius: 4px;
  padding: 2px 6px;
}
```

---

## 7. 測試案例

### 7.1 正常流程測試

| 步驟 | 操作 | 預期結果 |
|------|------|----------|
| 1 | 輸入「ABC庫存分類」 | 顯示思考過程和任務計劃 |
| 2 | 回覆「是」 | 繼續執行工作流 |
| 3 | 完成後 | 顯示執行結果 |

### 7.2 JSON 格式化問題測試

**問題**：LLM 返回的 JSON 樣本中 `{` 和 `}` 沒有正確跳脫

**解決**：在 Prompt 中使用 `{{` 和 `}}` 跳脫

```python
INTENT_CLASSIFICATION_PROMPT = """...
```json
{{
  "intent": "CLARIFICATION",
  ...
}}
```
..."""
```

### 7.3 換行問題測試

**問題**：任務計劃所有步驟擠在一行

**解決**：在 Prompt 中明確要求每個 Step 換行

```python
<plan>
Step 1: [動作] 描述（第一步驟）
Step 2: [動作] 描述（第二步驟）
Step 3: [動作] 描述（第三步驟）
...
</plan>

重要：每個 Step 必須獨立一行，換行輸出。
```

---

## 8. 常見問題

### Q1: 為什麼要用 WebSocket 而不是 HTTP？

**A**:
- 及時性：Server Push 機制，無需輪詢
- 雙向通信：支持工作流繼續
- 串流傳輸：思考過程分段顯示

### Q2: SSE 和 WebSocket 如何選擇？

**A**:
- **WebSocket**：需要雙向通信、工作流繼續
- **SSE**：只需要 Server Push（如日誌串流）

### Q3: 思考過程如何分段？

**A**:
- 後端在 LLM 返回的 `<thinking>` 標籤內按段落分割
- 前端接收到每個 `thinking` 事件後追加到現有內容

### Q4: 如何處理用戶快速輸入？

**A**:
- 使用 `abortController` 中斷舊請求
- 每次發送前檢查並關閉舊 WebSocket 連接

---

## 9. 相關文檔

| 文檔 | 說明 |
|------|------|
| `Agent-意圖分類與業務處理架構.md` | BPA 架構說明 |
| `MM-Agent-架構v3.md` | MM-Agent 完整架構 |
| `Agent 任務編排todo執行統一規範.md` | TODO 執行規範 |

---

## 10. 版本歷史

| 版本 | 日期 | 變更 |
|------|------|------|
| v1.0.0 | 2026-02-09 | 初始版本 |

---

**文檔創建日期**: 2026-02-09
**最後更新**: 2026-02-09
