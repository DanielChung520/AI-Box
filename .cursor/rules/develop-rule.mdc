---
alwaysApply: true
---
凡是創建代碼檔案，最上方備註：代碼功能說明、創建日期、創建人（Daniel Chung）、最後修改日期
凡是要創建、修改日期，請先上網(https://tw.piliapp.com/time/)確認當天的日期及時間
配置規範（2025-11-25 22:46 UTC+8）：敏感資訊集中於 .env / Secret；非敏感環境參數寫入 config/config.json（由 config/config.example.json 派生），新增欄位時需同步更新樣板與文檔

## 類型注解規範（2025-11-27 13:00 UTC+8）

### 必須使用類型注解的情況
1. **全局變量**：如果可能為 None，必須使用 `Optional[T]`
   ```python
   # ❌ 錯誤
   _service: KGBuilderService = None

   # ✅ 正確
   _service: Optional[KGBuilderService] = None
   ```

2. **函數參數**：如果默認值為 None，必須使用 `Optional[T]`
   ```python
   # ❌ 錯誤
   def func(model_type: str = None):

   # ✅ 正確
   def func(model_type: Optional[str] = None):
   ```

3. **局部變量**：複雜類型或可能為 None 的變量需要類型注解
   ```python
   # ✅ 正確
   temp_queue: PriorityQueue = PriorityQueue()
   model: Optional[BaseRTModel] = None
   bind_vars: dict = {}
   ```

4. **類屬性**：所有類屬性都應該有類型注解
   ```python
   class Service:
       _primary_model: Optional[BaseModel] = None
       _fallback_model: Optional[BaseModel] = None
   ```

### 類型匹配要求
- 使用正確的類型，不要混用（如 `List[Dict]` vs `List[WorkflowTelemetryEvent]`）
- 對象類型要匹配（如 `CrewResourceQuota` 對象而非 `int`）
- 避免隱式 Optional，明確使用 `Optional[T]` 或 `T | None`

## 防御性編程規範（2025-11-27 13:00 UTC+8）

### None 檢查要求
1. **數據庫連接**：使用前必須檢查是否為 None
   ```python
   # ❌ 錯誤
   collection = self.client.db.collection(COLLECTION_NAME)

   # ✅ 正確
   if self.client.db is None:
       raise RuntimeError("ArangoDB client is not connected")
   collection = self.client.db.collection(COLLECTION_NAME)
   ```

2. **可選參數**：處理可能為 None 的參數
   ```python
   # ❌ 錯誤
   parser = get_parser(file_type)  # file_type 可能是 None

   # ✅ 正確
   if file_type is None:
       file_type = "text/plain"  # 提供默認值
   parser = get_parser(file_type)
   ```

3. **模型對象**：使用前檢查是否已初始化
   ```python
   # ❌ 錯誤
   doc = self._model(text)  # _model 可能是 None

   # ✅ 正確
   if self._model is None:
       raise RuntimeError(f"Model {self.model_name} is not available")
   doc = self._model(text)
   ```

4. **AQL 查詢**：檢查 aql 屬性是否可用
   ```python
   # ✅ 正確
   if self.client.db is None or self.client.db.aql is None:
       raise RuntimeError("AQL is not available")
   cursor = self.client.db.aql.execute(aql, bind_vars=bind_vars)
   ```

### API 調用檢查
- 調用外部 API 前，確認參數名稱和類型正確
- 檢查函數簽名，不要傳入不存在的參數
- 使用 IDE 的類型提示功能驗證參數

## 代碼結構規範（2025-11-27 13:00 UTC+8）

### Import 語句規範
1. **位置**：所有 import 必須在文件頂部，在模塊文檔字符串之後
   ```python
   """模塊說明"""

   from typing import Optional, List
   from fastapi import APIRouter
   # ❌ 錯誤：不要在代碼中間添加 import
   ```

2. **順序**：
   - 標準庫 import
   - 第三方庫 import
   - 本地模塊 import
   - 類型相關 import（如 `from typing import ...`）

### 變量使用規範
1. **未使用的變量**：必須刪除或使用
   ```python
   # ❌ 錯誤：定義但未使用
   type_names = [rt.type for rt in filtered]
   pass

   # ✅ 正確：刪除未使用的變量，或添加註釋說明為什麼需要
   ```

2. **全局變量**：使用單例模式時，類型必須正確
   ```python
   # ✅ 正確
   _service: Optional[KGBuilderService] = None

   def get_service() -> KGBuilderService:
       global _service
       if _service is None:
           _service = KGBuilderService()
       return _service
   ```

### 文件格式規範
1. **文件末尾**：必須有換行符（由 pre-commit hook 自動修復）
2. **行尾空格**：不允許有 trailing whitespace（由 pre-commit hook 自動檢查和修復）
3. **代碼格式化**：使用 black 自動格式化
4. **類型檢查**：提交前必須通過 mypy 檢查

**Pre-commit Hooks 自動檢查項目**：
- ✅ **trailing-whitespace**：自動移除行尾空格
- ✅ **end-of-file-fixer**：自動修復文件末尾格式（確保文件末尾有換行符）
- ✅ **black**：自動格式化 Python 代碼
- ✅ **ruff**：自動檢查和修復代碼風格問題
- ✅ **mypy**：類型檢查（必須通過）
- ✅ **check-yaml/json/toml**：配置文件語法檢查
- ✅ **check-added-large-files**：檢查大文件（>1MB）
- ✅ **check-merge-conflict**：檢查合併衝突標記
- ✅ **check-case-conflict**：檢查文件名大小寫衝突

**提交前必須確保**：
- 所有 pre-commit hooks 檢查通過
- 如果檢查失敗，會自動修復部分問題，請重新提交修復後的代碼

## 代碼審查檢查清單（2025-11-27 13:00 UTC+8）

### 提交前必須檢查
- [ ] 所有類型注解完整且正確
- [ ] 所有可能為 None 的值都有檢查
- [ ] Import 語句在文件頂部
- [ ] 沒有未使用的變量
- [ ] 通過 pre-commit hooks（black, ruff, mypy）
- [ ] API 調用參數正確
- [ ] 數據庫連接使用前有 None 檢查
- [ ] 模型對象使用前有可用性檢查

### 常見錯誤模式
1. **類型不匹配**：`List[Dict]` vs `List[WorkflowTelemetryEvent]`
2. **缺少 Optional**：`T = None` 應為 `Optional[T] = None`
3. **缺少 None 檢查**：直接使用可能為 None 的對象
4. **Import 位置錯誤**：在代碼中間添加 import
5. **API 參數錯誤**：傳入不存在的參數名

## 工具使用規範（2025-11-27 13:00 UTC+8）

### 開發時使用
- 啟用 IDE 的類型檢查功能
- 使用 mypy 進行類型檢查：`mypy .`
- 使用 ruff 進行代碼檢查：`ruff check .`
- 使用 black 進行格式化：`black .`

### CI/CD 檢查
- pre-commit hooks 必須全部通過
- mypy 類型檢查必須通過
- ruff 代碼檢查必須通過
- black 格式化檢查必須通過


## Git 提交前檢查規範（2025-01-27 14:00 UTC+8）

### 提交前必須執行的步驟

**重要**：每次提交代碼前，必須確保所有 pre-commit hooks 檢查通過。如果檢查失敗，提交會被阻止。

#### 1. 自動修復步驟（推薦）

```bash
# 方法一：使用 pre-commit 自動修復（推薦）
pre-commit run --all-files

# 方法二：手動運行各個工具
# 格式化代碼
black .

# 檢查和修復代碼風格
ruff check --fix .

# 類型檢查（只檢查，不自動修復）
mypy .
```

#### 2. 提交流程

```bash
# 1. 添加文件到暫存區
git add .

# 2. 提交（pre-commit hooks 會自動運行）
git commit -m "your commit message"

# 如果 hooks 失敗，會自動修復部分問題，然後需要：
# - 重新添加修復後的文件：git add .
# - 重新提交：git commit -m "your commit message"
```

### Pre-commit Hooks 檢查項目詳解

#### Black 代碼格式化檢查

**檢查內容**：
- 代碼格式是否符合 Black 規範
- 行長度、縮進、引號使用等

**常見錯誤**：
- 代碼格式不符合 Black 規範
- 行尾有多餘空格
- 文件末尾缺少換行符

**修復方法**：
```bash
# 自動格式化所有文件
black .

# 格式化特定文件
black path/to/file.py

# 檢查但不修改（dry-run）
black --check .
```

**注意事項**：
- Black 會自動修改文件格式，修改後需要重新 `git add`
- 如果 Black 修改了文件，提交會失敗，需要重新提交

#### Ruff 代碼風格檢查

**檢查內容**：
- 未使用的變量（F841）
- 未使用的導入
- 代碼風格問題
- 潛在的 bug

**常見錯誤**：
- `F841: Local variable 'xxx' is assigned to but never used`
- 未使用的導入
- 代碼風格不符合規範

**修復方法**：
```bash
# 自動修復可修復的問題
ruff check --fix .

# 只檢查不修復
ruff check .

# 檢查特定文件
ruff check path/to/file.py
```

**注意事項**：
- Ruff 會自動修復部分問題，但有些問題需要手動修復
- 未使用的變量必須刪除或使用
- 修復後需要重新 `git add`

#### Mypy 類型檢查

**檢查內容**：
- 類型注解是否正確
- 類型是否匹配
- 是否有類型錯誤

**常見錯誤**：
- `error: "Redis" expects no type arguments, but 1 given`
- `error: Argument 1 has incompatible type`
- `error: Item "X" has no attribute "__iter__"`
- `error: Unsupported right operand type for in`

**修復方法**：
```bash
# 檢查所有文件
mypy .

# 檢查特定文件
mypy path/to/file.py

# 忽略缺失的導入（用於第三方庫）
mypy --ignore-missing-imports .
```

**常見類型錯誤修復**：

1. **Redis 類型注解錯誤**：
   ```python
   # ❌ 錯誤
   self._redis: Optional[redis.Redis[str]] = None

   # ✅ 正確（redis-py 不支持類型參數）
   self._redis: Optional[redis.Redis] = None
   ```

2. **異步操作類型錯誤**：
   ```python
   # ❌ 錯誤（忘記 await）
   result = self._redis.get(key)

   # ✅ 正確（同步 Redis）
   result = self._redis.get(key)
   # 或使用類型忽略（如果確定是同步的）
   result = self._redis.get(key)  # type: ignore[union-attr]
   ```

3. **ArangoDB 查詢結果類型**：
   ```python
   # ❌ 錯誤
   document = collection.get(session_id)
   if "messages" in document:  # 類型錯誤

   # ✅ 正確
   document = collection.get(session_id)
   if document is not None and isinstance(document, dict):
       if "messages" in document:
   ```

### 提交失敗處理流程

#### 情況 1：Black 格式化失敗

**錯誤信息**：
```
black....................................................................Failed
- hook id: black
- files were modified by this hook
```

**處理步驟**：
1. Black 已經自動修復了文件
2. 重新添加修復後的文件：`git add .`
3. 重新提交：`git commit -m "your message"`

#### 情況 2：Ruff 檢查失敗

**錯誤信息**：
```
ruff.....................................................................Failed
- hook id: ruff
- exit code: 1
- files were modified by this hook
```

**處理步驟**：
1. 檢查 Ruff 的錯誤信息
2. 如果 Ruff 自動修復了，重新添加：`git add .`
3. 如果有需要手動修復的問題（如未使用的變量），手動修復後重新添加
4. 重新提交

#### 情況 3：Mypy 類型檢查失敗

**錯誤信息**：
```
mypy.....................................................................Failed
- hook id: mypy
- exit code: 1
```

**處理步驟**：
1. 查看 mypy 的詳細錯誤信息
2. 根據錯誤信息修復類型問題
3. 如果無法修復（如第三方庫類型問題），使用 `# type: ignore[error-code]` 註釋
4. 重新添加和提交

### 提交前檢查清單

在執行 `git commit` 前，請確保：

- [ ] 已運行 `black .` 格式化代碼
- [ ] 已運行 `ruff check --fix .` 修復代碼風格問題
- [ ] 已運行 `mypy .` 檢查類型（或至少檢查修改的文件）
- [ ] 所有測試通過（如果有）
- [ ] 代碼符合項目規範
- [ ] 沒有未使用的變量或導入
- [ ] 所有類型注解正確

### 快速修復命令

```bash
# 一鍵修復所有可自動修復的問題
black . && ruff check --fix . && git add .

# 然後檢查類型（不會自動修復）
mypy . || echo "有類型錯誤，需要手動修復"

# 最後提交
git commit -m "your message"
```

### 常見問題解決方案

#### Q1: pre-commit hooks 一直失敗，如何跳過？

**不推薦跳過**，但如果有緊急情況：
```bash
# 跳過 pre-commit hooks（不推薦）
git commit --no-verify -m "your message"
```

**注意**：跳過 hooks 會導致代碼質量問題，應該盡量避免。

#### Q2: 如何只檢查特定文件？

```bash
# 只檢查特定文件
black path/to/file.py
ruff check path/to/file.py
mypy path/to/file.py
```

#### Q3: 如何更新 pre-commit hooks？

```bash
# 更新 pre-commit hooks
pre-commit autoupdate

# 重新安裝 hooks
pre-commit install
```

#### Q4: 如何查看詳細的錯誤信息？

```bash
# 查看詳細的 mypy 錯誤
mypy . --show-error-codes

# 查看詳細的 ruff 錯誤
ruff check . --verbose

# 查看詳細的 black 錯誤
black . --diff
```

### 開發環境設置

確保開發環境已正確設置：

```bash
# 1. 激活虛擬環境
source venv/bin/activate  # Linux/Mac
# 或
venv\Scripts\activate  # Windows

# 2. 安裝 pre-commit
pip install pre-commit

# 3. 安裝 pre-commit hooks
pre-commit install

# 4. 安裝開發依賴
pip install black ruff mypy
```

### 持續集成（CI）檢查

在 CI/CD 流程中，這些檢查也會自動運行：
- 所有 pre-commit hooks 必須通過
- 類型檢查必須通過
- 代碼格式化檢查必須通過

如果 CI 檢查失敗，請在本地修復後重新提交。

## 項目控制表更新規範（2025-01-27 14:00 UTC+8）

### 更新 PROJECT_CONTROL_TABLE.md 的強制要求

**重要**：更新 `docs/PROJECT_CONTROL_TABLE.md` 時，**必須在原有文件基礎上進行更新**，**嚴禁直接創建新文件或覆蓋整個文件**。

#### 更新原則

1. **必須讀取現有文件**：更新前必須先讀取現有的 `PROJECT_CONTROL_TABLE.md` 文件內容
2. **局部更新**：只更新需要修改的部分（如任務狀態、完成日期、進度百分比等）
3. **保留原有結構**：保持文件的整體結構、格式和未修改的內容不變
4. **禁止覆蓋**：不得使用 `write` 工具直接覆蓋整個文件

#### 正確的更新方式

**✅ 推薦方式 1：使用 Python 腳本讀取-修改-寫回**

```python
# 讀取現有文件
with open("docs/PROJECT_CONTROL_TABLE.md", 'r', encoding='utf-8') as f:
    content = f.read()

# 只修改需要更新的部分
content = content.replace("舊狀態", "新狀態")
# 或使用正則表達式精確匹配需要更新的行

# 寫回文件
with open("docs/PROJECT_CONTROL_TABLE.md", 'w', encoding='utf-8') as f:
    f.write(content)
```

**✅ 推薦方式 2：使用 sed 或 grep 進行局部替換**

```bash
# 使用 sed 替換特定行
sed -i 's/舊內容/新內容/g' docs/PROJECT_CONTROL_TABLE.md
```

**✅ 推薦方式 3：使用 search_replace 工具進行精確替換**

```python
# 使用 search_replace 工具，提供足夠的上下文確保唯一匹配
search_replace(
    file_path="docs/PROJECT_CONTROL_TABLE.md",
    old_string="| 5.1.1 | LLM Router 核心 | 2 天 | ⏸️ | 0% | - | - | AI-1 |",
    new_string="| 5.1.1 | LLM Router 核心 | 2 天 | ✅ | 100% | 2025-01-27 | 2025-01-27 | AI-1 |"
)
```

#### 錯誤的更新方式（禁止）

**❌ 錯誤方式 1：直接創建新文件**

```python
# ❌ 禁止：直接創建新文件
write("docs/PROJECT_CONTROL_TABLE.md", "新內容...")
```

**❌ 錯誤方式 2：覆蓋整個文件**

```python
# ❌ 禁止：讀取備份文件然後覆蓋原文件
with open("backup.md", 'r') as f:
    content = f.read()
with open("docs/PROJECT_CONTROL_TABLE.md", 'w') as f:
    f.write(content)  # 這會丟失原文件中的其他更新
```

**❌ 錯誤方式 3：不讀取原文件就更新**

```python
# ❌ 禁止：不讀取原文件，直接寫入
content = "新內容..."
with open("docs/PROJECT_CONTROL_TABLE.md", 'w') as f:
    f.write(content)
```

#### 更新前檢查清單

在更新 `PROJECT_CONTROL_TABLE.md` 前，必須：

- [ ] 確認已讀取現有文件內容
- [ ] 確認只更新需要修改的部分
- [ ] 確認保留文件的整體結構
- [ ] 確認未修改的內容保持不變
- [ ] 確認更新後的格式正確（Markdown 表格格式）

#### 更新後驗證

更新完成後，應該驗證：

- [ ] 文件格式正確（Markdown 表格可以正常渲染）
- [ ] 未修改的內容仍然存在
- [ ] 更新的內容正確反映實際進度
- [ ] 文件結構完整（所有章節都存在）

#### 常見更新場景示例

**場景 1：更新單個任務狀態**

```python
# 讀取文件
with open("docs/PROJECT_CONTROL_TABLE.md", 'r', encoding='utf-8') as f:
    content = f.read()

# 更新特定任務
content = content.replace(
    "| 5.1.1 | LLM Router 核心 | 2 天 | ⏸️ | 0% | - | - | AI-1 |",
    "| 5.1.1 | LLM Router 核心 | 2 天 | ✅ | 100% | 2025-01-27 | 2025-01-27 | AI-1 |"
)

# 寫回文件
with open("docs/PROJECT_CONTROL_TABLE.md", 'w', encoding='utf-8') as f:
    f.write(content)
```

**場景 2：更新階段進度**

```python
# 讀取文件
with open("docs/PROJECT_CONTROL_TABLE.md", 'r', encoding='utf-8') as f:
    content = f.read()

# 更新進度
content = content.replace(
    "| **階段五** | LLM MoE 階段 | ... | 🔄 進行中 | 25% |",
    "| **階段五** | LLM MoE 階段 | ... | 🔄 進行中 | 78.6% (11/14) |"
)

# 寫回文件
with open("docs/PROJECT_CONTROL_TABLE.md", 'w', encoding='utf-8') as f:
    f.write(content)
```

**場景 3：批量更新多個任務**

```python
# 讀取文件
with open("docs/PROJECT_CONTROL_TABLE.md", 'r', encoding='utf-8') as f:
    content = f.read()

# 定義更新映射
updates = {
    "| 5.1.1 | ... | ⏸️ | 0% |": "| 5.1.1 | ... | ✅ | 100% | 2025-01-27 | 2025-01-27 |",
    "| 5.1.2 | ... | ⏸️ | 0% |": "| 5.1.2 | ... | ✅ | 100% | 2025-01-27 | 2025-01-27 |",
}

# 批量更新
for old, new in updates.items():
    content = content.replace(old, new)

# 寫回文件
with open("docs/PROJECT_CONTROL_TABLE.md", 'w', encoding='utf-8') as f:
    f.write(content)
```

#### 緊急情況處理

如果誤操作導致文件損壞：

1. **立即停止**：不要繼續修改
2. **檢查 Git 歷史**：使用 `git log docs/PROJECT_CONTROL_TABLE.md` 查看歷史版本
3. **恢復備份**：如果有備份文件（如 `.backup`），從備份恢復
4. **從 Git 恢復**：使用 `git checkout HEAD -- docs/PROJECT_CONTROL_TABLE.md` 恢復到最後一次提交的版本
5. **手動修復**：如果以上方法都不可用，手動對比並修復文件

#### 總結

**核心原則**：
- ✅ **必須**在原有文件基礎上更新
- ✅ **必須**先讀取現有文件內容
- ✅ **必須**只更新需要修改的部分
- ❌ **禁止**直接創建新文件
- ❌ **禁止**覆蓋整個文件
- ❌ **禁止**不讀取原文件就更新

遵循這些規範可以確保項目控制表的更新不會丟失已有的進度記錄，避免因誤操作導致的數據丟失。
